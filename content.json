{"pages":[],"posts":[{"title":"Java基础笔记：集合Collection","text":"集合Collection是java中最强大的“数据引擎”，它规范了在应用中管理对象组的方式 一. 集合框架基础java集合框架标准化了程序处理对象组的方式。jdk1.5对集合框架进行了大幅修改，增加了泛型、自动装箱和拆箱以及for-each风格的for循环。在泛型之前，集合中存储的都是Object类型的引用，而使用泛型可以明确声明集合中要存储的对象的类型，避免出现运行时类型不匹配的错误，泛型给集合带来了“类型安全”的特性。 集合只能存储引用类型，不能存储基本类型，因为自动装箱和自动拆箱特性的存在，当集合要存储基本类型的数据时，java会自动完成装箱和拆箱的工作。所有集合类都实现了Iterable接口，可以使用for-each风格的for循环遍历访问集合中的所有元素。 二. 集合接口集合框架定义了一些核心接口，集合类只是提供了集合接口的不同实现方法 Collection接口： Collection接口是构建集合框架的基础，每个集合类都直接或间接实现了该接口。interface Collection&lt;E&gt; Collection是泛型接口，泛型参数E指定了集合将要存储的对象的类型。Collection接口声明了所有集合都将拥有的核心方法： add()：向集合中添加对象，添加的元素的类型必须和集合指定的类型匹配，添加成功就返回true contains()：判断集合中是否包含指定元素 isEmpty()：判断调用集合是否为空 remove()：从调用集合中移除指定实例 size()：返回调用集合中元素的数量 Iterator iterator()：返回调用集合的一个迭代器对象 List接口： List接口扩展了Collection，List用于依次添加元素到集合中，添加元素的顺序就是索引元素的顺序。列表的索引从0开始，使用元素的位置插入或访问元素，列表中可以包含重复的元素。List中定义的方法： add( int index，E obj )：将元素插入指定索引位置，插入点及之后位置存储的元素将被后移 get( int index )：返回列表中指定索引位置处存储的元素 remove( int index )：移除指定索引位置处存储的元素 set( int index，E obj )：将指定索引位置处的元素替换为给定的对象obj，并返回该位置原来的对象 Set接口： Set接口声明了集中不允许有重复的元素，如果为Set集添加相同的元素就返回false. Queue接口： Queue接口扩展了Collection接口，并且声明了队列的行为，队列通常是先进先出的列表。队列只能从头部获取或移除元素，只能从队尾添加元素，Queue中声明的方法： offer( E obj )：试图将对象obj添加到队列中，添加成功返回true E element()：返回队列头部元素，但不移除该元素，如果队列为空返回NoSuchElementException异常 peek()：返回队列头部的元素，如果队列对空则返回null，不移除元素 poll()：返回队列头部元素，在操作过程中移除元素，如果队列为空返回null remove()：移除队列头部元素，并在操作过程中返回该元素，队列为空则抛出NoSuchElementException异常 三. 集合实现类java为集合接口提供了很多标准实现类，有的是抽象类，有的类则具有完整的实现。作为一般规则，集合类不是同步的，但是java为并发环境提供了集合实现类的同步版本。 ArrayList类： ArrayList类扩展了AbstractList类并且实现了List接口，ArrayList类支持能够按需增长的动态数组，本质上就是长度可变的动态数组。ArrayList类的构造函数： 123456// 创建一个ArrayList对象new ArrayList();// 创建一个ArrayList对象，并且使用指定集合中的元素初始化new ArrayList(Collection&lt;? extends E&gt; c);// 创建初始容量为capacity的ArrayList对象new ArrayList(int capacity); 1234567891011121314151617181920212223242526public class ArrayListToArray { public static void main(String[] args) { // 创建一个ArrayList对象 ArrayList&lt;Integer&gt; al = new ArrayList&lt;&gt;(); // 此处发生了自动装箱 al.add(1); al.add(2); al.add(3); al.add(4); System.out.println(\"Contents of al: \" + al); // ArrayList转数组，并且指定了数组中元素的类型 Integer ia[] = new Integer[al.size()]; ia = al.toArray(ia); int sum = 0; for (int i : ia) { sum += i; } System.out.println(\"Sum is: \" + sum); }} LinkedList类： LinkedList类扩展了AbstractSequentialList类，实现了List、Deque以及Queue接口，并提供了一种链表的数据结构。 HashSet类： HashSet类用于创建使用哈希表存储元素的集合。哈希表使用称为散列的机制存储信息，在散列机制中，键的信息用于确定唯一的值，称为哈希码。然后使用哈希码作为索引，在索引的位置存储与键关联的数据。散列机制的优势是对于add()、contains()、remove()以及size()方法的执行时间保持不变，即使对于比较大的Set也是这样，因为不像List那样需要去遍历集合。因为散列处理过程通常不创建有序的组，所以HashSet不能保证元素的顺序。 LinkedHashSet类： LinkedHashSet维护组中条目的一个链表，链表中的元素的顺序也就是插入它们的顺序，这使得可以按照插入顺序迭代集合。 TreeSet类： TreeSet创建使用树进行存储的组，对象以升序存储，访问和检索速度非常快，这对于存储大量的、必须能够快速查找到的有序信息来说非常重要。 四. 迭代器迭代器用于遍历集合中的元素，迭代器实现了Iterator接口，该接口中声明的方法非常简单： hashNext()：如果集合中还有更多的元素就返回true next()：返回集合中下一个元素 remove()：移除当前元素 每一个集合类都提供了iterator方法，该方法返回一个指向集合开头元素的迭代器，使用该迭代器对象可以依次访问集合中的每一个元素 123456789101112131415161718192021public class IteratorDemo { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(\"C\"); list.add(\"A\"); list.add(\"E\"); list.add(\"B\"); list.add(\"D\"); list.add(\"F\"); // 获取迭代器对象用于遍历集合 Iterator&lt;String&gt; itr = list.iterator(); while (itr.hasNext()) { // 获取集合中的下一个对象 String element = itr.next(); System.out.print(element + \" \"); } }} 如果不需要在迭代集合的过程中修改元素的内容，可以使用for-each循环迭代集合： 1234567891011121314151617public class ForEachDemo { public static void main(String[] args){ // 创建一个集合对象 List&lt;Integer&gt; vals = new ArrayList&lt;Integer&gt;(); vals.add(5); vals.add(4); vals.add(3); vals.add(2); vals.add(1); // for-each循环 for (int v : vals) { System.out.print(v + \" \"); } }} 五. 映射Map映射Map是存储键值对关联关系的对象，Map中的键和值都是对象Object，键key必须是唯一的，值value是可以重复的。映射类没有实现Iterator接口，所有无法直接获取迭代器遍历映射对象，但是可以获取映射的集合视图Set&lt;Map.Entry&lt;&gt;&gt;，由于是Set集合，所以可以使用for-each风格的循环迭代 Map接口：Map接口将唯一的键映射到值上，键key是用于检索值value的对象。Map中的核心方法是put()和get()方法： put()：将值value放入到映射中，覆盖之前与此键关联的值 get()：返回与键key关联的值，如果没有找到键则返回null Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()：该方法返回包含所有映射条目（键值对）的Set集合，集合中包含的对象是Map.Entry类型的，可以迭代方法键值对中的信息 Map.Entry接口：该接口提供了操作映射条目Item的功能，它表示一个键值对映射对象，包含键和值的信息 K getKey()：获取映射项中键对象key V getValue()：获取映射项中的值对象Value HashMap类：HashMap类实现了Map接口，使用哈希表存储映射，HashMap的优势是get()和put()方法执行时间保持不变。HashMap不能保证元素的顺序！ 123456789101112131415161718public class HashMapDemo { public static void main(String[] args) { HashMap&lt;String, String&gt; hm = new HashMap&lt;&gt;(); hm.put(\"book1\", \"《Java编程思想》\"); hm.put(\"book2\", \"《MySQL必知必会》\"); hm.put(\"book3\", \"《数据结构与算法》\"); hm.put(\"book4\", \"《JavaScript高级编程》\"); // 获取映射项的组视图 Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet(); // 遍历组视图 for (Map.Entry&lt;String, String&gt; entry : entrySet) { System.out.print(entry.getKey() + \": \"); System.out.println(entry.getValue()); } }} TreeMap类：该类用于创建存储在树结构中的映射，与HashMap不同，TreeMap中树映射确保元素以键的升序存储，支持快速检索 LinkedHashMap类：在映射中以插入条目的顺序维护一个条目链表，当遍历LinkedHashMap的集合视图的时候，将以元素的插入顺序返回元素","link":"/2018/10/29/java/java-base-collection/"},{"title":"Java基础笔记：面向对象","text":"封装、继承和多态是面向对象编程的三大基础 一. 类Class类是对象的模板，它定义了对象的成员变量和成员方法，是一种逻辑结构。类Class也定义了一种数据类型（引用类型），可以使用这种新的类型创建该类型的对象。在定义类的时候一般要声明它的属性和方法，类中定义的变量称为成员变量，该类的所有对象都有一个这个变量的副本。 1234567// class关键字表明要定义一个类，同时也定义了一种Box类型的数据类型class Box { // 定义类的成员变量 double width; double height; double depth;} 创建对象： 获取一个类的对象需要经过两个步骤： 声明一个该类型的引用变量variable 获取该类型的实例instance并将其引用（内存地址值）赋值给引用变量 Box box = new Box()，这行代码首先声明了一个Box类型的引用变量box，然后使用new运算符在运行时动态地为对象分配内存空间，然后将这个内存地址值赋值给引用变量box，new运算符后面跟着是构造函数，它定义了创建对象时发生的操作（初始化对象），类中如果没有显式地定义构造函数，那么编译器会自动的提供一个默认的无参构造函数。 当将一个对象的引用变量赋值给另一个对象引用变量的时候，不是创建对象的副本，而是创建引用副本 1234// 此时变量b1和b2指向同一个对象，因为在将变量b1赋值给b2时// 并不是创建对象的副本，而是将b1存放的内存地址值赋值给b2，创建的是引用的副本Box b1 = new Box();Box b2 = b1; 二. 方法方法的本质是定义了操作对象中变量的接口，方法的一般形式： 123456type methodname(parameter-list){ // 方法体 // 事先已经声明过的变量variabale return variable;} type指定了方法返回的数据的类型，可以是基本类型primary或者引用类型object，如果方法不返回值，那么他的返回类型就是void. parameter-list是方法的参数列表，参数的本质是方法中的局部变量，当调用方法的时候它们用于接收为方法传递的值。return语句用于方法返回值，返回值的类型一定要和声明的type类型相匹配，可以存在隐式的类型转换。 构造函数：构造函数的名称和类名称相同，语法上和方法类似，但构造函数没有返回值类型，因为返回值隐式的为对象本身。在使用new运算符创建对象之后，jvm会立即调用构造函数来初始化对象，如果类中没有显式地定义构造函数，java会调用一个默认的无参构造函数，同时将有的成员变量初始化为默认值（0 / false / null），构造函数的任务就是初始化对象内部状态。构造函数也可以带有参数，这些参数用于初始化对象中的变量。 12345678910111213public class Box { double width; double height; double depth; // 自定义的带参构造函数，参数用于初始化对象中的变量 public Box(double w, double h, double d) { System.out.println(\"Constructing Box...\"); width = w; height = h; depth = d; }} this关键字：在方法中可以使用this关键字指向调用该方法的对象。this关键字的另一个用法是当方法中的局部变量（包括方法入参）和类的成员变量名称相同的时候，局部变量会覆盖类的成员变量，此时使用this关键字可以明确指向类的成员变量。 方法的重载：在同一个java类中定义多个名称相同的方法是合法的，只要方法的参数类型或者数量不同即可，这些方法被称为是重载的。当调用重载的方法的时候，jvm会根据传递给方法的参数的实际类型与方法的形参之间的比较来决定具体调用哪个方法。构造函数的重载是很常见的，一个类往往会有过个重载的构造函数。 给方法传递对象作为参数：除了基本类型的参数之外，方法还可以接受对象作为参数（废话）。java中的参数传递分为两种： 值调用 call-by-value：将实参的值赋值给形参，实参值后续的变化不会影响形参 引用调用 call-by-reference：在这种情况下，实参因为保存的是对象的内存地址值，传给形参的也是地址值，所以实参变量和形参变量指向是同一个对象，实参属性的改变会影响实参属性 static关键字：在类中可以使用static关键字修饰变量和方法，将变量和方法声明为静态的。静态变量和方法可以使用类名直接调用，不需要通过任何类的对象引用。静态变量本质就是全局变量了，所有的对象共享的是相同的静态变量，而不是保存的变量副本。 静态变量可以使用静态代码块去初始化，而且静态代码块只会执行一次，就是在类加载的时候 1234567891011121314151617181920212223public class UseStatic { // 静态变量相当于全局变量 static int a = 3; static int b; static void meth(int x) { System.out.println(\"x = \" + x); System.out.println(\"x = \" + a); System.out.println(\"x = \" + b); } // 静态代码块，在类加载的时候就会执行，所以它会在meth()方法之前执行 static { System.out.println(\"Static block initialized.\"); b = a * 4; } public static void main(String[] args) { // 调用静态方法，不需要通过任何类的对象引用，直接调用 meth(42); }} final关键字：final关键字可以用于修饰变量、方法或者类 使用final修饰的变量值是不可被改变的，实际上就变成了常量，final修饰的变量必须在声明的时候就初始化 使用final修饰的方法可以防止被子类重写，这对于类中一些关键的核心方法很重要，防止被错误重写 final也可以修饰类，此时这个类就不可被继承了，同时也隐式地将类中所有方法也声明为final的，因为类不能被继承了，方法也就更不可被重写了 三. 继承继承是面向对象编程的一大特性，子类在继承父类的时候会得到父类所有的属性和方法，并且子类可以添加自己特有的属性和方法，所以子类是父类的特殊化版本。子类不能访问父类中声明为private的私有属性和方法，但是声明为protected的变量和方法子类是可以访问的。 多态：父类的引用变量是可以指向子类对象的！当将指向子类对象的引用赋值给父类引用变量的时候，父类引用只能访问那些在父类中定义的属性和方法，子类中自己定义的属性和方法时无法访问到的。 super关键字：对于父类中的私有属性和方法，子类引用是无法直接调用的，此时可以在子类中使用super关键字来表示引用子类的直接超类。super关键字主要有两种用法：第一种是在子类构造函数中调用超类的构造函数，第二种是访问超类中被子类隐藏的成员变量（子父类中存在同名变量，糟糕的设计），super()必须是子类构造函数中的第一条语句，如果自己没有写，则编译器会默认加上。 构造函数调用时期：在类层次中，从超类到子类按照继承顺序调用构造函数，并且super()必须是子类构造函数中的第一条语句，如果没有显式调用，那么编译器会默认加上超类的无参构造函数 方法的重写：如果子类中的某个方法和超类中的某个方法具有相同的方法名和参数列表，那么称子类重写了父类中的该方法，此时在子类中调用重写的方法的时候，总是指向由子类定义的版本，如果希望调用父类定义的版本，则需要使用super关键字明确指出。 动态方法调用：动态方法调用是一种机制，它允许java在运行时而不是编译时解析对重写方法的调用，举例来说，如果一个接口中的某个方法被多个实现类所重写，当使用接口类型的引用变量调用这个方法的时候，jvm会根据引用变量所指向的对象的实际类型来决定具体调用哪个方法重写版本！多态是面向对象编程的基础之一，多态允超类规定对所有继承类或实现类都通用的方法，并允许子类重新定义其中的方法实现。 抽象类：有的时候方法在超类中可以没有具体实现，继承抽象类的子类要么实现抽象方法，要么本身也是抽象类。为了确保某些方法必须被子类所重写，可以将该方法声明为抽象方法abstract，抽象方法没有方法体，任何一个包含一个或多个抽象方法的类都必须声明为抽象类。由于抽象类的定义是不完整的，所有抽象类不能使用new实例化对象，同时抽象类也不能声明构造函数和静态方法。虽然抽象类不能实例化，但是定义抽象类的引用变量是合法的。 1234567891011121314151617// 抽象类abstract class A { // 抽象方法，没有方法体 abstract void callme(); void callmeto(){ System.out.println(\"这是一个具体的方法\"); }}class B extends A { // 重写超类中的抽象方法，给出方法的具体实现 @Override void callme() { System.out.println(\"B's implementation of callme.\"); }} Object类：Object类是java中的“上帝类”，java中的所有类都直接或间接继承该类，Object类中提供了很多非常重要的方法 Class&lt;?&gt; getClass()：在运行时动态获取对象所属的类型 int hashCode()：获取对象关联的哈希码 wait() / notify() / notifyAll()：线程中的通信方法 boolean equals( Object obj )：判断一个对象是否和另一个对象相等 四. 访问控制包的作用package：包是多个类的容器，包的路径和类名组成唯一的标识用于类名称空间的互相隔离。包既是命名机制，也是一种可见性机制。 访问修饰符：java提供了四种不同类别的可见性修饰符 private：成员变量或方法能被同一个类中的成员访问 无访问修饰符：同一个包下的非子类可以访问 protected：不同包下的子类可以访问 public：任何地方都可以访问 五. 接口interface接口是对类的高度抽象，接口是一种规范，它规定了类必须实现的方法，所以接口中的所有方法都没有方法体。一个类只能继承一个超类，但是可以实现任意数量的接口，只要为接口中的方法提供完整的实现即可。如果一个类只实现了接口中的部分方法，那么这个类必须声明为抽象类abstract。 接口被设计为支持运行时动态方法解析（多态），即接口类型的引用变量可以指向实现类的对象，当调用接口中的方法时，jvm会根据引用变量实际指向的对象的类型来判断具体调用哪个版本的方法，利用多态机制可以实现“一个接口，多种实现方法”。 接口中是可以声明变量的，只是这些变量都隐式的标识为static和final，这意味着接口的实现类不能修改他们，并且在声明的时候就必须初始化。接口中的方法和变量都被隐式声明为public 1234567891011121314151617public interface Callback { // 接口中的方法和变量都隐式地声明为public void callback(int num);}public class Client implements Callback{ // 实现接口中定义的方法，必须声明为public，因为接口中定义的方法隐式地声明为public @Override public void callback(int p) { System.out.println(\"callback called with: \" + p); } // 在实现类中定义自己的成员方法 void nonIfaceMethod(){ System.out.println(\"Methods defined by class...\"); }} 六. 异常处理异常Exception是程序中运行时的错误，java使用面向对象的方法来管理异常，当出现引起异常的情况时就会创建用来表示异常的的对象Throwable，并在引起异常的方法中抛出异常对象。 异常的类型： java中所有的异常类型都是内置类Throwable的子类，Throwable有两个子类 Exception：这种类型异常用于表示应用程序应该捕获的异常，用户也可以创建继承自该类的子类异常 Error：这种异常定义了常规环境下不应该被应用程序捕获的异常，这类异常会被java运行时系统捕获，通常是那些堆栈溢出等灾难性的失败，这些异常即使被应用程序捕获也无法处理 未捕获的异常： 应用的一旦出现异常，就必须有一个异常处理程序来捕获并处理异常，如果应用程序自己没有捕获异常，那么这些异常将由jre默认的异常处理程序捕获，默认的异常处理程序会输出异常点的堆栈追踪信息，并且默认的异常处理程序会导致程序终止运行，假如是web应用就会终止服务！ 堆栈追踪信息指明了异常发生的位置：类名、方法名、异常发生的代码行 使用try和catch： 使用try和catch自己处理异常的好处主要是阻止程序自动终止。try封装需要监视的代码块，catch子句指定了希望捕获的异常类型，一旦try中抛出了catch指定类型的异常，该异常就会被catch子句捕获，程序的控制权将由try语句转移到catch子句中，而catch中封装了处理异常的程序，比如给前端返回一段异常信息，并在后台记录异常，以便程序调试。执行完catch子句之后，程序的控制就会继续进入到程序中整个try / catch代码块的下一行，程序不会终止 12345678910111213141516171819public class Exc2 { public static void main(String[] args) { int d, a; // 封装了可能发生异常的代码块 try { d = 0; a = 42 / d; // 上一行发生异常，这一句不会被执行 System.out.println(\"This will not be printed.\"); } catch (ArithmeticException e) { // 捕获并处理异常，此处只是简单地在控制台打印异常信息 System.out.println(\"Division by zero\"); } // try/catch之后的代码会被执行 System.out.println(\"After catch statement.\"); }} throw关键字： 除了java运行时系统抛出的异常之外，程序也可以使用throw关键字手动抛出异常，throw语句之后的代码将不会被执行。异常既然抛出来了，jre就会检查有没有与之类型匹配的catch子句，如果没有则这些异常将由jre默认的异常处理程序所捕获，打印堆栈追踪信息，程序终止 123456789101112131415161718192021222324public class ThrowDemo { // 该方法会发生异常，但是自己有处理程序 static void demoproc() { try { // 手动创建java的标准异常对象并抛出异常对象 throw new NullPointerException(\"demo\"); } catch (NullPointerException e) { // 捕获异常 System.out.println(\"Caught inside demoproc\"); // 再次抛出异常 throw e; } } public static void main(String[] args) { try { // 该方法将抛出异常 demoproc(); } catch (NullPointerException e) { // 再次捕获异常 System.out.println(\"Recaught: \" + e); } }} throws关键字： 如果方法可能发生的异常自己不能处理，则需要指明这种行为，以便方法的调用者可以自己编写异常处理程序。在方法上使用throws子句可以声明方法可能抛出的所有异常类型，除了Error和RuntimeException之外的异常类型都需要这么做 12345678910111213141516public class ThrowsDemo { // 方法会产生异常，但自己不使用try/catch处理，而是使用throws关键字显式地抛出 static void throwOne() throws IllegalAccessException { System.out.println(\"Inside throwOne\"); throw new IllegalAccessException(\"demo\"); } public static void main(String[] args) { // 方法的调用者捕获并处理异常 try { throwOne(); } catch (IllegalAccessException e) { System.out.println(\"Caught \" + e); } }} finally关键字： 考虑这种情况，方法中获取了一个数据库连接资源Connection，然后方法执行出现异常，此时Connection并未被关闭，依然占用系统资源，假如有很多Connection对象都打开着，数据库系统资源将很快被耗尽导致数据库宕机。关键姿finally就是用来解决这种问题的，finally子句中的代码会在try/catch代码块之后执行，不管方法是否发生异常都会执行finally子句中的代码。","link":"/2018/10/11/java/java-base-oop/"},{"title":"Java基础笔记：基本语法","text":"java基本语法：数据类型、变量、数组、控制语句，这些都是java语法中最基础的概念 一. Java语言简介java的起源：1991年Sun公司的 James Gosling 和同事开始着手开发一门被称为Oak的编程语言（1995年更名为Java），java起初是被用于嵌入各种消费类电子产品中的（微波炉、机顶盒…），由于这些电子产品的cpu各不相同，所以java的设计初衷是可移植、平台独立、适用于各种类型cpu环境下的编程工作 java的兴起：java的出现正值万维网浪潮的兴起，也正是随着万维网的发展，java逐渐兴起并成为Web服务端开发最流行的编程语言！ 字节码：java源代码经过编译器编译之后成为字节码bytecode，字节码是高度优化的指令集合，这些指令由java虚拟机执行。字节码文件可以运行在针对指定操作系统而专门设计的java虚拟机中，这正是java实现跨平台的基础 java的一些特性： 简单：java继承了很多c/c++的语法特性，但是舍弃了很多比较难用的特性，比如指针和垃圾回收 面向对象：在java中除了基本类型之外，其它的一切都是对象，正真的“万物皆对象” 多线程：java在语言层面提供了对多线程的支持 健壮性：java是强类型的语言，在编译的时候会进行类型兼容性检查，及时发现代码中的兼容性问题，同时java对程序员屏蔽了内存管理，使得开发者可以无需手动分配和释放内存资源 二. Java语言基础面向对象编程（Object-Oriented Programming）是java的核心，相对于面向对象的是面向过程（c/c++），它将程序描述为一系列线性的步骤。面向对象的一个本质特征就是抽象abstraction，抽象的概念被用于管理应用程序中的复杂性。开发中可以通过抽象，将应用划分为组件对象component的集合，而应用中的处理步骤就变成了组件对象之间的消息传递过程。 面向对象的三大特性： 封装：封装是将代码及其操作的数据绑定在一起的机制，java中封装的基础是类Class，类定义了对象的结构和行为（variable / method），类是一种逻辑结构而对象是一种物理实体（占用内存空间）。封装的目的是处理应用的复杂性。 继承：继承是一个对象获得另一个对象属性和方法的过程，通过继承，子类获得了父类所有属性和方法，同时子类只需要定义自己独有的属性和方法即可。继承最大的好处是提高了代码的复用性。 多态：多态的概念简而言之就是：超类（Class / Interface）的引用变量可以指向子类对象！如果超类中的某个方法被多个子类实现或重写，此时使用超类引用变量调用这个方法的时候，jvm会根据超类引用变量所指向的子类对象的实际类型来调用具体的方法，这就是动态方法调用！ 第一个java程序： java源文件的扩展名称必须是.java格式的，源文件名称需要和类名称保持一致 123456789// class是java关键字，表示正在定义一个新的java类class HelloWorld { // public是访问修饰符，用于控制类成员的可见性 // static关键字表示不需要实例化类就能够调用该方法 // main()方法表示这是程序的入口 public static void main(String[] args){ System.out.println(\"Hello Java!\"); }} 三. Java语法基础数据类型 data type： java是强类型的语言，java中的每个变量都有一种类型。在java中的赋值，不管是显式地赋值还是在方法中传参，都要进行类型兼容性检查，如果不兼容将编译失败，这也是java安全性和健壮性的原因之一。 java中的数据类型可分为基本类型和引用类型（对象），java中的基本类型可以分为四组： 整型：byte、short、int、long，它们都是用于表示整数的，长度分别是1byte，2byte，4byte，8byte，常用的是int和long类型，它们都是有符号的整数且数值范围严格定义，int是32位有符号整数，范围大概是正负21亿，long的范围是天文数据，大概几百万亿亿 浮点型：float和double类型，它们用于表示浮点数，常用是double类型，它是64位的 字符型：在java中用于存储字符的数据类型是char，java使用Unicode表示字符，所以java中char类型是16位的，这样有利于国际化 布尔型：boolean类型用于表示逻辑值，它只有true和false两个可能值 变量 variable： 在java程序中，变量是最基本的存储单元，变量通过联合标识符、类型和可选的初始化器来定义。变量的基本声明形式type identifier [ = value]，type 指明变量的类型（int / boolean/ User / ModelAndView…），identifier是变量的名称，变量可以在声明的时候就初始化，也可以在后续动态初始化（赋值对象的引用） 12345678// 声明了三个int类型的变量int a, b, c;// 声明了一个double类型的变量，并初始化double pi = 3.1415;// 声明一个引用类型的变量，变量mv的类型是ModelAndView，并且已经初始化了ModelAndView mv = new ModelAndView(); 此外所有的变量都有作用域，作用域决定了变量的可见性和生存周期。java中的作用域是使用代码块即花括号来定义的，java中的作用域主要分为类作用域和方法作用域。类级作用域的变量对类中所有的方法都是可见的，而方法级作用域的变量（包括方法入参）只在本方法中可见。作用域也是嵌套的，外层作用域中声明的变量对内层作用域可见，反之不成立。 变量的生命周期被限制在作用域之内，当进入变量的作用域时创建变量，当离开它们的作用域时销毁变量，这也是为什么方法中的变量不会出现线程安全问题的原因！ 数组 Array： 数组是以通用的名称引用一组类型相同的变量（基本类型或引用类型），数组中的特定元素通过索引来访问。数组变量的声明形式type var-name[size]，type决定了数组中元素的类型，size指定数组的容量 123456789101112// 声明并初始化一个数组变量，new运算符用于为数组申请内存空间// 通过new分配的数组，根据数组的类型，其中的元素会被自动初始化为0、false、null// 数组的索引是从0开始的，这是常识// 声明并初始化一个数组变量int month_days[] = new int[12];// 另一种数组初始化方式double nums[] = {10.1, 11.2, 12.3, 13.4};// 这样写也合法double[] nums = {10.1, 11.2, 12.3, 13.4}; 四. 控制语句java中的程序控制语句分为：选择语句、迭代语句和跳转语句 选择语句： 12345678910111213141516171819202122232425262728// if-else，表达式为true执行statement1if (condition){ // statement1} else { // statement2}// switch是java的多分支语句，将表达式的值与case语句中的每一个值进行比较，一旦匹配就执行这条case语句// 如果常量值与case语句中的值匹配，就执行default语句// break用于终止语句，当遇到break的时候执行过程将进入整个switch语句后面的第一行代码for (int i = 0; i &lt; 6; i++) { switch (i) { case 0: System.out.println(\"i is zero\"); break; case 1: System.out.println(\"i is one\"); break; case 2: System.out.println(\"i is two\"); break; case 3: System.out.println(\"i is three\"); break; default: System.out.println(\"i is more than three\"); }} 迭代语句： 123456789101112131415161718192021222324252627282930// while循环，只要控制表达式为true就重复执行循环体，当为false时立即退出循环执行下一条语句int n = 10;while (n &gt; 0){ System.out.println(\"tick \" + n); n--;}// 如果希望至少执行一次循环体，即使控制表达式一开始就是false，此时可以使用do-while循环int n = 10;do { System.out.println(\"tick \" + n); n--;} while(n &gt; 0);// 传统的for循环，可以在for循环的初始化部分声明变量，该变量的作用域局限于for循环for (int n = 10; n &gt; 0; n--){ System.out.println(\"tick \" + n)}// for-each风格的循环被设计为以严格的顺序、从头到尾循环遍历一个对象集合int sum = 0;int nums[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};for (int x : nums){ System.out.println(\"Value is: \" + x); sum += x; if (x == 5) break; // 停止循环} 跳转语句： 1234567891011121314151617181920212223242526// 使用break语句可以强制立即终止循环，绕过循环表达式和循环体中的剩余代码，并且程序会继续恢复到循环后// 的下一条语句int i = 0;while (i &lt; 100){ if (i == 10) break; System.out.println(\"i: \" + i); i++;}System.out.println(\"Loop complete.\");// 与break不同的是，continue是停止处理循环体中本次迭代剩余的代码而进入下一次循环// continue语句导致程序的控制权被直接转移到控制循环的条件表达式中public class Continue { public static void main(String[] args) { for (int i = 0; i &lt; 10; i++) { System.out.print(i + \" \"); // 如果i是奇数就换行 if (i % 2 == 0) continue; System.out.println(\"\"); } }}// 使用return语句显式地从方法中返回，return语句导致程序的执行控制权从方法转移到方法的调用者","link":"/2018/10/03/java/java-base-grammer/"},{"title":"Java基础笔记：字符串与I/O流","text":"Java使用面向对象的方式处理字符串String，I/O流用于处理应用程序中的输入和输出 一. 字符串String类String可能是java标准类库中最常使用的类，与c/c++中使用字符数组表示字符串不同，java中创建的每个字符串实际上都是String类型的对象。String类型的对象是不可变的，一旦创建了一个String对象，其字符串内容就不能再改变。但java也提供了StringBuffer和StringBuilder类，它们允许修改字符串的内容。需要声明的是String对象的字符串内容是不可以改变的，但是String类型的引用变量reference是可以指向其他String类型的对象的！String类是被final关键字修饰的，不可以被继承。 构造字符串：String myString = &quot;This is a test&quot; 这段代码声明了一个字符串类型的变量myString，然后使用字符串字面值创建String对象。java中使用加号运算符（+）可以连接字符串，还可以使用字符数组创建String对象： 123456789// 使用字符串字面值创建String对象String myString = \"This is a test\";// 使用+运算符连接字符串，构建一个新的字符串对象String myString = \"I\" + \"love\" + \"Java\";// 使用字符数组创建String对象, 并且可以指定开始索引的位置和使用字符的数量char[] chars = {'a', 'b', 'c', 'd', 'e', 'f'};String s = new String(chars, 2, 3); String类中定义了很多操作字符串的方法： length()：获取调用该方法的字符串的长度 getBytes(Charset charset)：将字符串转为字节数组，同时指定编码的格式 toCharArray()：将字符串转换为字符数组 startsWith()和endsWith()：判断给定的字符串是否是以指定子串开头或结尾的 equals()与==：equals方法比较是两个String对象中的字符串内容是否相同，而==比较的是两个String类型的引用变量是否是指向同一个String类型的对象 indexOf()：查找给定字符或子串在字符串中第一次出现的位置的索引index substring()：String对象虽然是不可以改变的，但是可以使用String类提供的方法来构造字符串修改之后的新副本 trim()：返回调用字符串的副本，去除开头和结尾的空白字符 toLowerCase()：将字符串中所有字符都转换为小写字符 split()：根据指定的规则将字符串分割为几个部分 StringBuffer：StringBuffer表示可增长、可写入的字符串序列，StringBuffer允许在中间插入字符或子串，或者在末尾追加字符和子串 12345678// 默认预留16个字符的空间new StringBuffer();// 显式设置缓存区的大小new StringBuffer(int size);// 构建一个使用指定字符串初始化的StringBuffernew StringBuffer(String str); StringBuffer中的那些方法： capacity()：获取StringBuffer已分配的容量 append()：将其它类型数据的字符串表示形式连接到调用该方法的字符串末尾，也就是拼接字符串 reverse()：反转StringBuffer对象中的字符 replace()：可以使用一个字符集替换StringBuffer对象中的另一个字符集，比如在jdbc操作中，sql语句中的占位符?可以被对应的sql参数所替代 StringBuilder：jdk1.5中添加了一个新的类StringBuilder，StringBuilder与StringBuffer作用类似，只是StringBuilder中的方法不是同步的，所以有线程安全的问题，StringBuilder的优势是性能更高。如果某个字符串对象被多个线程并发修改且没有其它同步措施的话，必须使用StringBuffer。StringBuffer线程安全的原因是它里面的方法使用了synchronized关键字修饰，使得这些方法都是同步的。 二. I/O流1. 流stream中的基本概念： java程序通过流stream执行输入输出I/O，流是java中一种高度抽象的概念，它要么使用信息InputStream，要么产生信息OutputStream，java中的流一般分为磁盘文件File和网络socket。 java定义了两种类型的流： 字节流：定义了处理字节数据byte的输入和输出的方法，比如在读取和写入二进制数据时（图片），使用的就是字节流 字符流：jdk1.1新增，底层还是字节流，但为处理字符char输入输出提供了方便的方法，比如读取web.xml文件到内存，它们使用的Unicode编码 字节流基础：字节流的顶层抽象类是InputStream和OutputStream，分别代表输入流和输出流，它们定义了流类中的一些核心方法，最重要的是read()和write()，分别表示读取和写入字节数据。并且根据字节流所连接的实体，可以对字节流的类型进行划分： BufferedInputStream / BufferedOutputStream：针对内存缓冲的输入输出流，从缓冲对象Buffer中读取字节数据或向缓冲对象Buffer中写入字节数据 ByteArrayInputStream / ByteArrayOutputStream：针对字节数组的字节流对象 FileInputStream / FileOutputStream：针对文件系统的字节流，可以读取文件字节数据，或者向文件写入字节数据 字符流基础：与字节流一样，字符流也是通过两个顶层抽象类定义的，分别是Reader和Writer，这两个类是用于处理Unicode字符流。Reader和Writer定了字符流中的核心方法，最重要的是read()和write()，分别代表读取和写入字符数据。根据字符流连接的实体，可以对字符流进行划分： BufferedReader / BufferedWriter：针对内存缓冲的字符输入输出流 CharArrayReader / CharArrayWriter：针对字符数组的输入输出流 FileReader / FileWriter：针对文件对象，读取字符数据或写入字符数据 读写文件基础：读写文件最常用的是使用FileInputStream和OutputStream，使用这两个类创建与文件连接的字节流。读取文件内容主要分为三步：创建连接到文件的输入流、调用read方法一个字节一个字节地循环读取文件中的数据，最后记得关闭流对象。 123456789101112131415161718192021222324252627282930313233343536public class ShowFile { public static void main(String[] args) { // 表示从文件中读取的一个字节数据 int i; FileInputStream fin; try { // 使用File对象创建一个文件输入流 fin = new FileInputStream( new File(\"D:\\\\code\\\\idea\\\\java_base\\\\src\\\\com\\\\znker\\\\TEST.txt\")); } catch (FileNotFoundException e) { System.out.println(\"Cannot Open File.\"); return; } try { // 使用输入流循环读取文件中的内容，每次读取一个字节，并作为整型值返回 // 当到达文件末尾的时候返回-1 do { i = fin.read(); if (i != -1) System.out.print((char) i); } while (i != -1); } catch (IOException e) { System.out.println(\"Error Reading File.\"); } // 关闭文件输入流，释放系统分配的资源 try { fin.close(); } catch (IOException e) { System.out.println(\"Error Closing File.\"); } }} 2. 探究java.io： 在java中网络连接Socket、内存缓冲Buffer、磁盘文件File都可以作为I/O类操作。 File类：File类直接处理文件和文件系统，File类不是指定如何读写文件内容，而是描述了文件本身的属性。File对象用于获取和操作与磁盘文件关联的信息，如权限、时间日期、目录路径….在java中，目录被简单地作为带有附加信息的File对象。 File类的构造函数： 12// 使用文件的路径名创建File对象new File(String pathname); File类中的那些方法： getName()：获取文件名称 getPath()：获取文件的路径 isDirectory()：是否为目录 length()：文件的长度 isFile()：如果调用的是文件则返回true，如果是目录则返回false 字节流：字节流的顶层类是InputStream和OutputStream，字节流可以用于操作任何类型的对象，包括二进制数据，比如图像、txt文档、excel表格。InputStream中定义的重要方法： read()：读取下一个可用的字节整数，当到达文件末尾的时候返回-1 avaliable()：返回当前可读取的输入字节数 close()：关闭输入源，如果再次尝试读取将会产生IOException异常 OutputStream定义了流字节输出： write( int b )：向输出流中写入单个字节 flush()：结束输出状态，清空缓冲区 close()：关闭输出流 FileInputStream类：使用FileInputStream类创建的InputStream对象可以用于从文件中读取字节 123456789101112131415161718192021222324252627package com.znker.cp20;import java.io.FileInputStream;import java.io.IOException;public class FileInputStreamDemo { public static void main(String[] args) { int size; // 带资源关闭的try语句，不用手动关闭流了 // 使用完整的文件路径名称作为FileInputStream构造函数的参数 try (FileInputStream f = new FileInputStream(\"D:\\\\code\\\\idea\\\\java_base\\\\src\\\\com\\\\znker\\\\cp20\\\\FileInputStreamDemo.java\")) { // 当前可读取的输入字节数，该值与输入指针位置有关 System.out.println(\"Total Available Bytes: \" + (size = f.available())); int n = size / 40; System.out.println(\"First \" + n + \" bytes of the file one read() at a time\"); for (int i = 0; i &lt; n; i++) { System.out.print((char) f.read()); } System.out.println(\"\\nStill Available: \" + f.available()); } catch (IOException e) { e.printStackTrace(); } }} 字符流：字节流的缺点是不能直接操作Unicode字符，Reader和Writer抽象类位于字符流的顶层，可以用于操作字符流。 12345678910111213141516171819public class FileWriterDemo { public static void main(String[] args) { String source = \"Now is the time for all good men\\n\" + \"to come to the aid of their country\\n\" + \"and pay their due taxes.\"; // 字符数组 char[] buffer = new char[source.length()]; // 将source转换为字符数组 source.getChars(0, source.length(), buffer, 0); try (FileWriter fw = new FileWriter(\"D:\\\\code\\\\idea\\\\java_base\\\\src\\\\com\\\\znker\\\\cp20\\\\file.txt\")){ // 将字符数组中的数据写入到文件中 fw.write(buffer); } catch (IOException e) { System.out.println(\"An I/O Error Occurred\"); } }}","link":"/2018/10/19/java/java-base-string-and-io/"},{"title":"JavaWeb编程基础：Servlet技术","text":"Servlet技术是javaweb编程的核心，它用于处理客户端的请求与响应 一. JavaWeb开发中的基本概念1996年Sun公司发布了Java Servlet技术，该技术后来成为在Web应用中生成动态内容的标准。Servlet是运行在服务端的java类，用于处理客户端的http请求并作出响应html，运行在服务端的servlet接收由servlet容器（tomcat/jetty）转发的针对指定URL的请求（HttpRequest），web应用程序使用web.xml或者注解映射URL和servlet之间的关系。起初的servlet响应是全部写在servlet程序中的，使用PrintWriter对象将html响应页面的内容一行行地写回客户端（html），这要求java程序员需要精通网页编程技术，同时由于硬编码使得debug非常困难。JavaServer Pages（jsp）技术的出现改变了这一现状，jsp本质还是servlet，jsp技术允许在html文档中嵌入java脚本程序用于动态生成需要查询数据库的内容，这样使得页面中的静态资源（html/text/image/href…）和动态内容得以分离，静态资源直接写在html模板内，而动态内容查询数据库之后使用jsp标签（EL）渲染到模板页面中。Servlet和JSP程序需要部署在servlet/jsp容器中才能运行，常见的servlet/jsp容器有tomcat和jetty，servlet容器和客户端（browser/app）之间使用HTTP协议进行通信。 二. Servlet接口Servlet api是javaweb开发技术的基础，它的核心是Servlet接口。Servlet接口是servlet容器和servlet程序之间的一种“契约”，它约定servlet容器会加载servlet类到内存中（init），当servlet容器接收到客户端针对特定URL的http请求时，容器会调用该servlet类中的方法（service）去处理请求并作出响应。在servlet容器将http请求转发给servlet程序之前，servlet容器会事先创建一个ServletRequest和ServletResponse对象，其中servlet容器解析了http请求报文的原始数据，并将解析后的数据封装到ServletRequest对象中，开发者调用ServletRequest对象中的方法即可获取相应的请求信息和请求参数parameter，而ServletResponse对象则代表了servlet程序对http请求的响应（html/json…），它封装了响应的复杂性。 Servlet接口中的方法，这些方法都是由servlet容器调用的，这些方法也是servlet生命周期方法： init：当第一次请求servlet时，servlet容器会调用该方法初始化servlet对象到内存当中，在调用这个方法的时候servlet容器还会传递一个ServletConfig对象给该方法，ServletConfig对象中封装了servlet的初始化参数，这些初始化参数定义在web.xml或者注解中 service：该方法用于处理客户端请求，每次请求servlet的时候，容器都会调用这个方法，同时传递给service方法两个对象参数：ServletRequest &amp; ServletResponse，service方法从ServletRequest对象中获取请求参数，然后调用web应用中的javabean组件操作数据库并完成业务逻辑，将需要返回的结果对象寄存在request请求作用域中，然后将http请求转发给jsp模板页面用于页面渲染返回结果。如果想要返回JSON格式的数据，则调用json序列化工具（Jackson）将返回的结果序列化之后由ServletResponse对象直接写回客户端。 destroy：当应用程序卸载或者servlet容器关闭的时候由servlet容器调用，释放系统资源。 12345678910111213141516171819202122232425262728293031323334353637383940// 使用注解开发Servlet而不是web.xml// @WebServlet注解表示这个类是一个Servlet，urlPatterns元素告知servlet容器匹配请求的URL@WebServlet(name = \"MyServlet\", urlPatterns = {\"/my\"})public class MyServlet implements Servlet{ private transient ServletConfig servletConfig; @Override public void init(ServletConfig servletConfig) throws ServletException { this.servletConfig = servletConfig; } @Override public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException { String servletName = servletConfig.getServletName(); // 设置响应的格式为html页面，并指定页面编码格，默认是ISO-8859-1，中文会乱码 response.setContentType(\"text/html;charset=utf-8\"); // PrintWriter对象，用于将响应的html页面发送到客户端 PrintWriter writer = response.getWriter(); // 设置HTTP请求响应的内容，其中servletName为动态获取的 writer.print(\"&lt;html&gt;&lt;head&gt;&lt;/head&gt;\" + \"&lt;body&gt;Hello from \" + servletName + \"&lt;/body&gt;&lt;/html&gt;\"); } @Override public ServletConfig getServletConfig() { return servletConfig; } @Override public String getServletInfo() { return \"My Servlet\"; } @Override public void destroy() { }} javaweb应用具有特定的目录结构，其中WEB-INF目录下的资源不能被客户端直接访问，只能由web程序内部访问。web应用的部署：将整个应用程序打包为war格式，然后复制到tomcat的webapps目录下，然后启动tomcat即可，也可以使用IDE配置tomcat自动部署。 在浏览器中输入http://http://localhost:8080/my，查看返回的页面源码正是servlet中PrintWriter对象输出的内容，这样就完成了一次http的请求和响应过程 三. ServletRequest对于每一个http请求，servlet容器都会创建一个ServletRequest对象传递个servlet的service方法，servlet容器解析了http请求中的原始请求数据（请求头信息&amp;请求参数parameter），servlet容器将解析后的数据封装到了ServletRequest对象中，其中最重要的就是请求参数。getParameter()方法可以获取表单域（form）中的请求参数值，也可以获取查询字符串的值Query，例如对于http://localhost:8080/role?id=233请求，如果参数名不存在则返回null 1234567891011@WebServlet(name = \"roleServlet\", urlPatterns = {\"/role\"})public class RoleServlet extends HttpServlet{ @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // 使用getParameter方法获取查询字符串的值 String roleId = request.getParameter(\"id\"); System.out.println(roleId); }} ServletRequest对象中的那些重要方法： setAttribute() / getAttribute() / removeAttribute()：ServletRequest本身是一个作用域，该对象可以用于存储键值对key-value类型的数据，该作用域的范围仅限于一次请求响应过程中，因为在service方法结束后，request对象将被jvm垃圾回收掉，而Request域中的对象也会被销毁 getContentType：获取http请求体中的类型，比如在上传图片的时候就可能是 image/png getInputStream：从请求体中获取二进制的数据，结果返回一个ServletInputStream对象 getParameter( java.lang.String name )：获取指定名称的请求参数的值 getRequestDispatcher( java.lang.String path )：获取一个请求转发器对象，该对象中封装了转发的地址 ServletRequest最重要的作用是该对象中封装了请求信息和参数，在service方法中可以使用这些数据！ 四. ServletResponseServlet容器在调用servlet的service方法之前会创建一个ServletResponse对象用于表示对于http请求的响应，该对象隐藏了将响应发送给客户端的复杂性。在jsp出现之前，如果响应格式是html页面，则需要手动调用getWriter方法获取PrintWriter对象后将页面一行行写回到客户端！如果响应格式是二进制数据（文件下载），使用getOutStream方法获取一个输出流对象。jsp技术出现之后，在service方法完成业务逻辑返回结果之后，可以将结果对象存放到request作用域中，然后将请求转发给jsp页面，而将响应页面发送到客户端的过程将由jsp编译之后的servlet默认执行。 ServletResponse对象中的那些重要方法： getWriter：该方法返回一个java.io.PrintWriter对象，该对象可以将响应结果的html页面写回客户端 getOutputStream：该方法返回一个输出流对象，用于处理二进制文件下载，比如图片、文档…. setContentType：因为PrintWriter对象默认的编码格式是IOS-8859-1，在处理中文响应的时候需要手动设置编码格式为utf-8，否则会出现页面中文乱码问题 五. ServletConfig在servlet容器初始化servlet时，会给servlet的init方法传递一个ServletConfig对象，该对象中封装了servlet的初始化参数，这些参数是通过@WebServlet 或者web.xml部署描述符设定的。这些参数也是用键值对存储，这些参数在整个servlet生命周期中都可以调用。ServletConfig的另一个重要的方法是getServletContext()，该方法用于在servlet内获取与servlet关联的ServletContext对象！ 六. ServletContextServletContext对象表示web应用程序的上下文，每个web应用程序只有一个context，在servlet容器初始化web应用的时候就会创建这个对象，ServletConfig对象的getServletConfig()方法可以获取这个对象。因为ServletContext作用域为整个web应用生命周期，所以它可以跨servlet存储数据。 七. HttpServletHttpServlet类继承了GenericServlet抽象类，并且覆盖了service方法，传递给service方法的对象变成HttpServletRequest和HttpServletResponse，在HttpServlet中无需重写service方法，只需要重写doGet，doPost方法就可以处理HTTP请求，细节可查看源码： 123456789101112131415public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException { HttpServletRequest request; HttpServletResponse response; // 类型校验 if (!(req instanceof HttpServletRequest &amp;&amp; res instanceof HttpServletResponse)) { throw new ServletException(\"non-HTTP request or response\"); } // 向下转型总是会成功的 request = (HttpServletRequest) req; response = (HttpServletResponse) res; // 调用HttpServlet自定义的service(HttpServletRequset，HttpServletResponse) service(request, response);} 对于Http类型的请求，servlet容器还是会调用原始的service方法，但是会在该方法中对request和response对象进行向下的类型转换，然后调用HttpServlet中自定义的service方法，与GenericServlet不同的是对于HttpServlet对象只需要重写doGet/doPost方法就可以处理对应的Get/Post类型的http请求 HttpServletRequst对象中多了几个针对http类型请求的方法： getContextPath：获取请求路径的URI getCookies：获取http请求中的所有Cookie对象，返回值为一个Cookie类型的数组 getSession：获取http请求关联的HttpSession对象，如果不存在就创建一个新的 HttpServletResponse： addCookie ( Cookie cookie )：向http响应中添加一个Cookie对象用于跟踪用户状态 sendRedirect ( String location)：重定向，参数可以是一个绝对路径或者相对路径 八. web.xml部署描述符以上案例使用的都是@WebServlet 注解标识Servlet，也可以使用web.xml来配置Servlet的映射关系以及初始化参数等信息 1234567891011121314151617181920&lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version=\"3.0\"&gt; &lt;!-- 指定servlet的名称和路径 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;contextServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.znker.servlet.ContextServlet&lt;/servlet-class&gt; &lt;!-- 这个值大于0的时候表示服务器在启动的时候就会初始化这个servlet而不是客户端第一次访问 --&gt; &lt;load-on-startup&gt;10&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 配置servlet的映射路径，指定什么URL交由该servlet处理 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;contextServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/servletContext&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt; 九. Session管理HTTP协议是无状态的，在默认状态下，web服务器不知道一个http请求是来自用户首次访问还是来自之前已经访问过的用户，因此需要一种状态来保持用户状态。 Cookie： Cookie是自动地在web服务器和浏览器之间来回传递的一小块信息，cookie是作为http信息头嵌入的，因此它的传输过程由http协议处理，在服务端可以根据需求设置客户端cookie有效期限。 1234567891011121314151617181920212223// 创建Cookie对象Cookie cookie = new Cookie(cookie_name, value);// 将Cookie发送到浏览器// 当浏览器再次发出对同一资源或者同一台服务器中的不同资源的请求时，它会同时把从服务端发来的cookie// 在发送回去httpServletResponse.addCookie(cookie);// 在服务端访问客户端发来的Cookie中的信息Cookie[] cookies = request.getCookies();Cookie maxRecordsCookie = null;if(cookies != null) { // 迭代Cookie数组 for(Cookie cookie : cookies) { if(cookie.getName().equals(\"maxRecords\")) { maxRecordsCookie = cookie; } }}// Cookie类中没有可以直接删除cookie的方法，可以创建一个同名的Cookie去替换客户端的cookieCookie cookie = new Cookie(\"login\", \"\");cookie.setMaxAge(0);response.addCookie(cookie); HttpSession： HttpSession是当用户第一次访问某个网站的时候servlet容器自动创建的，通过在HttpRequest中调用getSession方法，可以获取用户的HttpSession，如果当前用户已经有与之关联的HttpSession了就返回这个对象，如果没有就创建一个新的HttpSession. 在HttpSession中可以用于存储键值对，这些信息是保存在服务端内存中的。 Servlet容器为它所创建的每一个HttpSession生成一个唯一的标识符，并将这个标识符作为一个token发送到浏览器，一般是作为一个名为JSESSIONID的cookie，在后续的请求中，浏览器会将这个Cookie发送回服务端，服务端通过解析这个HttpSession来确定是哪个用户发送的请求，HttpSession的发送和解析是由servlet容器自动完成的。为了使HttpSession强制过期，可以调用invalidate方法，用户退出登录状态的时候就可以调用这个方法。","link":"/2018/12/13/javaweb/javaweb-base-servlet/"},{"title":"jQuery基础笔记","text":"jQuery由于其优秀的浏览器兼容性，给处于ie6黑暗时代的开发者带来了福音，极大地解放了生产力 一. jQuery的概念jQuery是 John Resig 于2006创建的javascript开源函数库，凭借着简洁的语法和跨平台的兼容性（ie6），jquery极大的简化了js的开发，jquery的优势： 强大的选择器：jquery继承了css中选择器机制，避免了传统js中循环遍历节点获取DOM元素对象的过程 出色的DOM对象封装：jquery可以动态更新元素节点（element）以及元素节点的属性（attribute） 可靠的事件处理机制：在jquery中为元素对象绑定事件非常容易 完善的Ajax操作：jquery将js中的原生Ajax操作封装到了$.ajax()函数中，使得开发者只需要专注于业务逻辑，无需关心浏览器的兼容性以及XMLHttpRequest对象的创建和使用过程 jQuery1.11 中文文档下载 要使用jquery只需要在页面的公共位置引入jquery库即可： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello jQuery!&lt;/title&gt; &lt;!-- 使用公共CDN加载jQuery函数库 --&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=\"text/javascript\"&gt; // jQuery函数库中，$代表jQuery // ready()方法相当于传统javascript中的window.onload()方法，当时read()方法在DOM结构 // 加载完毕之后就执行了，onload()方法必须等网页所有相关元素（图片）加载完毕才执行 $(document).ready(function(){ alert(\"Hello jQuery!\"); }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; $(document).ready() 方法可以简写为： 1234// 使用匿名函数作为参数传递给jQuery函数$()$(function(){ alert(\"Hello jQuery!\");}); jQuery对象和DOM对象的区别： DOM对象是指在原生js中通过getElementById() 等方法获取的元素对象，jQuery对象是指通过jquery方法封装后的dom元素对象，只有jQuery对象才能使用jquery库中的方法，例如$(&quot;#foo&quot;).innerHTML是错误的 123456/* dom对象和jquery对象的互换 */var $variable = $(\"#foo\"); // 获取jquery对象，返回的是一个jquery对象数组var variable = $variable[0]; // 转为dom对象var variable = document.getElementById(\"foo\") // dom对象的获取var $variable = $(variable); // 将dom对象包装为jquery对象 二. jQuery中的选择器选择器是jquery的基础，在jquery中对于事件处理、DOM遍历、ajax操作都依赖于选择器，其核心思想是先要找到页面中的dom元素，然后改变dom元素的内容或者绑定事件效果。jquery的选择器技术继承自css，使用jquery选择器可以非常方便地找出页面中指定的jquery元素对象，添加相应的行为，避免了原生js的复杂遍历获取对象的过程。jquery选择器的优势是非常的简洁，$(#idName)就可以替代js中document.getElementById()函数。 jQuery中的选择器：jquery中的选择器种类非常多，主要分为获取jquery元素对象和过滤jquery元素对象。最常用的选择器是按dom元素的id属性或class属性来获取jquery对象，因为页面的中dom元素的id属性具有唯一性，所以这是最常用的。 12345678&lt;div id=\"notMe\"&gt;&lt;p&gt;id=\"notMe\"&lt;/p&gt;&lt;/div&gt;&lt;div id=\"myDiv\"&gt;id=\"myDiv\"&lt;/div&gt;&lt;span class=\"myClass\"&gt;span class=\"myClass\"&lt;/span&gt;&lt;script type=\"text/javascript\"&gt; $(\"#myDiv\"); // 根据dom的id元素匹配获取jquery对象 $(\".myClass\"); // 根据dom元素的class元素匹配获取jquery对象&lt;/script&gt; jQuery中还提供了很多辅助的选择器，这些选择器主要是用来过滤jquery对象的： 12345678910111213141516171819&lt;ul&gt; &lt;li&gt;list item 1&lt;/li&gt; &lt;li&gt;list item 2&lt;/li&gt; &lt;li&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt; &lt;li&gt;list item 5&lt;/li&gt;&lt;/ul&gt;&lt;table&gt; &lt;tr&gt;&lt;td&gt;Header 1&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Value 1&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;Value 2&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;script type=\"text/javascript\"&gt; $(\"li:first\"); // $(\"li\")根据标签获取的是一个jquery对象数组，该选择器过滤出第一个元素 $(\"tr:eq(1)\"); // 根据给定的索引获取元素&lt;/script&gt; 除此之外，还有诸如子类选择器，属性匹配选择器，表单元素选择器….需要的时候可以参考文档。 三. jQuery中的DOM操作每个html页面都能使用dom树表示出来，而js又能动态地改变这个dom结构，在使用jquery操作dom元素的时候往往会动态地创建html内容，使得dom文档在浏览器中呈现效果发生变化（dom结构或元素节点发生变化），而一旦dom结构发生变化，浏览器引擎就会重新渲染页面，这也是一种交互过程 元素节点查找：使用jquery选择器 12345678910111213&lt;p class=\"myClass\" title=\"shoppinglist\"&gt;购物列表：&lt;/p&gt;&lt;ul&gt; &lt;li title=\"牛肉\"&gt;牛肉&lt;/li&gt; &lt;li title=\"洋葱\"&gt;洋葱&lt;/li&gt; &lt;li title=\"苹果\"&gt;苹果&lt;/li&gt;&lt;/ul&gt;&lt;script type=\"text/javascript\"&gt; // 元素节点查找 var $li = $(\"ul li:eq(1)\"); // 获取&lt;ul&gt;中的第二个节点元素 var $li_txt = $li.text(); // 获取节点元素的文本内容 alert($li_txt);&lt;/script&gt; 查找元素节点的属性值：使用attr()方法可以获取元素节点的属性值 1234// 获取元素节点的属性值var $para = $(\"p\");var p_txt = $para.attr(\"title\");alert(p_txt); 创建节点：在dom操作中，常常要动态地创建html内容，append()方法用于将元素节点添加到dom树上 123// 创建&lt;li&gt;元素节点，并将它作为&lt;ul&gt;元素的子节点添加到dom节点树上var $li = $(\"&lt;li title='鸡蛋'&gt;鸡蛋&lt;/li&gt;\"); // 创建一个包含文本内容和属性的元素节点$(\"ul\").append($li); // 将新创建的元素节点插入到dom文档树上 删除节点：romove()方法可以将文档中某个多余的元素节点删除，包括该节点所包含的所有后代元素，方法的返回值是指向该删除的节点的引用 12var $li = $(\"ul li:eq(1)\").remove();$li.appendTo($li); // 洋葱跑到苹果后面了，dom文档结构发生了变化 节点的替换：使用replaceWith()方法将所有匹配的元素都替换成指定的dom元素，如果被替换的元素节点绑定了事件也一起删除 1$(\"li:eq(1)\").replaceWith(\"&lt;li title='橘子'&gt;橘子&lt;/li&gt;\"); 节点属性的操作：attr()方法可以用来获取和设置元素节点的属性，removeAttr()方法用于删除元素属性 1234567var $p = $(\"p\");var p_txt = $p.attr(\"title\"); // 获取节点指定属性的属性值console.log(p_txt);// 设置节点的属性，attr()方法可以同时设置多个属性$p.attr({\"title\":\"购物清单\", \"name\":\"shopping!!!\"});console.log($p.attr(\"name\")); // 在控制台查看效果 操作节点的样式：class属性也是节点的属性，可以使用attr()方法来操作属性值，样式文件定义在css文件中，jquery中还提供了addClass()方法来追加样式，removeClass()用于移除指定样式 设置和获取节点的html、文本和值：html()，text()，val() 123456789// html()方法用于获取某个节点的html内容，类似js中的innerHTML属性var p_html = $(\"p\").html();alert(p_html);// text()方法用于读取和设置某个元素节点中的文本内容var p_text = $(\"p\").text();console.log(p_text);$(\"p\").text(\"今天买点啥？\"); // 设置节点的文本内容 value()方法： 12345678910111213141516171819&lt;input type=\"text\" id=\"address\" value=\"请输入邮箱地址\"&gt;&lt;input type=\"text\" id=\"password\" value=\"请输入邮箱密码\"&gt;&lt;script type=\"text/javascript\"&gt; // value()方法用于获取和设置文本框、下拉菜单、单选框的值 $(\"#address\").focus(function(){ var txt_value = $(this).val(); // 获取节点的值 if(txt_value == \"请输入邮箱地址\"){ $(this).val(\"\"); // 设置节点的值为空 } }); $(\"#address\").blur(function(){ var txt_value = $(this).val(); // 获取节点的值 if(txt_value == \"\"){ $(this).val(\"请输入邮箱地址\"); } });&lt;/script&gt; 四. 事件JavaScript和HTML之间的交互是通过事件Event实现的，当文档或浏览器窗口发生一些特定的交互的时候，会触发浏览器生成一个事件对象，这个对象可以被浏览器browser捕获。与原生js相比，jquery提供了更加优雅的事件处理语法，增强了事件处理的能力。 $(document).ready() 是jquery中最重要的一个事件函数，用于替代原生js中的window.onload() 方法，$(function(){}); 是一种简写形式，当dom树结构加载和解析完毕之后，该函数绑定的方法就会被调用。 为元素绑定事件：jquery中可以使用bind(type, [data], fn)方法来为jquery对象绑定事件，其中type是事件的类型，data属性是传递给事件对象的额外数据对象，fn是指绑定的事件处理函数。事件的类型有很多，常见的有鼠标的单击和双击click、dbclick，元素获取或者失去焦点focus、blur 12345678910111213141516171819202122232425&lt;div id=\"panel\"&gt; &lt;h5&gt;什么是jQuery?&lt;/h5&gt; &lt;div style=\"display:none\"&gt; jQuery是一个优秀的javascript函数库！ &lt;/div&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; // 基本的事件绑定 $(\"#panel h5\").bind(\"click\", function(){ // this关键字是指携带相应行为的DOM元素 $(this).next().show(); }); // 常见的事件绑定可以简写 $(\"#panel h5\").click(function(){ var $content = $(this).next(); // 判断元素的可见性 if($content.is(\":visible\")){ $content.hide(); } else { $content.show(); } });&lt;/script&gt; 事件冒泡：如果页面上有多个元素同时响应一个事件，那么事件会按照dom的层次结构像水泡一样不断向上直到顶端。 1234567891011121314// 停止事件冒泡$(\".content\").click(function(event){ // do something... event.stopPropagation(); // event是指当前事件对象});// 有些网页内容是有默认行为的，比如单击超链接会跳转、单击提交按钮会提交表单，// 有时需要阻止这些默认行为，比如提交表单之前需要对表单数据进行校验$(\"#submit\").click(function(event){ // do something.... event.preventDefault(); // 阻止默认行为}); 五. Ajax基础1. Ajax的概念：ajax允许浏览器通过javascript向服务器发送HTTP请求接收数据，无需刷新整个页面！ 2. XMLHttpRequest对象：该对象是浏览器的内置对象，使用该对对象可以向服务器发送HTTP请求接收数据 123456789101112131415161718192021222324252627282930313233// 创建XMLHttpRequest对象var request = new XMLHttpRequest();// 初始化XMLHttpRequest对象，requestType请求类型GET/POST，url请求的地址，// async是否异步模式，默认是异步模式，如果是同步模式会锁定页面request.open(requestType, url, async);// XMLHttpRequest对象包含一个readystate属性，该属性的值是一个数字，用于表示请求的当前状态// 0 ---- 对象刚创建，未调用opne()方法初始化// 1 ---- 已调用open()方法初始化，未发送http请求// 2 ---- 请求已发送// 3 ---- 开始接收来自服务端的数据// 4 ---- 服务端响应完毕（200/404/500...）// readyState的属性值变化会触发readyStateChange事件，为事件绑定处理函数function reqReadyStateChange(){ // 服务端响应完毕 if(request.readyState == 4){ // http状态码200，请求成功 if(request.status == 200){ // responseText表示服务端返回的数据 alert(request.responseText); } else { alert(\"The server retutn a status code of \" + request.status); } }}request.onreadystatechange = reqReadyStateChange;// 发送请求，接收一个字符串类型的参数，参数为发送给服务器的请求体，如果不包含请求体，// 则将null作为值传入（必须）request.send(null); 六. jQuery对ajax的封装jQuery将ajax封装在$.ajax(url, [setting])中，该方法时jquery中ajax的底层方法，$.get()和$.post()都是对$.ajax()的封装 $.ajax()中的参数详情： async：是否为异步请求，默认是异步的 data：发送到服务器的数据 dataType：预期服务端返回的数据类型，xml、json、text、jsonp success：请求成功后的回调函数 12345678$.ajax({ url:\"xxx\", type:\"POST\", data:{key-value}, success:function(data){ // data是服务端返回的数据 alert(data); }}); $.get(url, data, callback, type) 通过GET请求获取数据： url：请求的地址 data：待发送给服务端的数据 callback：请求成功后的回调函数 type：返回数据的格式xml、json、text 12345$.get({\"xxx url\", {name:\"znker\"}, function(data){ // data服务端返回的数据 alert(data); }, \"json\"});","link":"/2019/01/13/javascript/jquery-notes/"},{"title":"MyBatis基础：组件与配置","text":"MyBatis的基本使用方法，重要的组件和基本配置 一. MyBatis简介Mybatis的前身是Apache的开源项目iBatis，2013年迁移到github上托管。Mybatis是一个java持久层的技术框架，它通过对jdbc的简单封装，实现了业务逻辑代码和SQL语句的分离，使得开发者能够从繁杂的dao层样板代码中解脱出来，可以专注于业务逻辑的开发。Mybatis的创新在于使用了基于接口的动态代理技术，使得数据访问层@repository 不需要实现类也可以运行，只需要一个dao层接口和xml映射文件即可，在接口中定义访问数据库的方法，在映射文件定义SQL语句。与Hibernate相同的是，它们都使用了某种方式使得应用中domain类和数据库中表之间建立了映射关系；与Hibernate不同的是，mybatis不屏蔽SQL，这对于性能要求极高或者需求经常变更的互联网应用来说非常友好，便于SQL语句优化。 MyBatis的特点： 不屏蔽SQL：这意味着便于对SQL语句进行优化，有利于系统性能调优 强大灵活的映射机制：并且具有动态SQL功能，可以根据查询条件动态构建SQL语句，而不需要在业务逻辑代码中手动拼装SQL语句，解放生产力！ 使用基于接口的动态代理技术，只需要一个Mapper接口和一个XML配置文件作为映射器即可 二. MyBatis中的那些核心组件1. SqlSessionFactoryBuilder &amp; SqlSessionFactory： SqlSessionFactoryBuilder是一个构造器，它会根据mybatis的核心配置文件（mybatis-config.xml）创建一个SqlSessionFactory对象，SqlSessionFactoryBuilder的生命周期为创建SqlSessionFactory对象的方法之内。SqlSessionFactory是一个工厂接口，mybatis中默认的实现类是DefaultSqlSessionFactory，它的作用是创建mybatis核心接口SqlSession的实现类对象，用于操作数据库。SqlSessionFactory的生命周期和应用程序是一样的，应该采取单例模式。 2. SqlSession： SqlSession是mybatis的核心接口，默认实现类是DefaultSqlSession，作用相当于jdbc中的Connection数据库连接对象，SqlSession有三个作用： 在基于接口代理的开发模式中，SqlSession可以获取Mapper接口的代理对象 使用SqlSession的api发送SQL语句操作数据库（iBatis的遗留方法，不建议使用） 控制数据库事务，相当于在jdbc中使用try…catch…finally手动控制事务。与Spring整合之后事务交由Spring去统一管理@Transactional 3. 映射器： 映射器是mybatis中最重要也是最复杂的组件，映射器由一个dao层的接口和一个xml映射文件组成，作用如下： 描述映射关系，建立domain类属性数据表中字段之间的静态映射关系，详见ResultMap 配置SQL语句，SQL语句查询参数设置，返回值类型设置，对返回的结果集ResultSet进行自动封装…. 根据前端传的查询条件进行动态构建SQL语句 映射器的作用主要是将SQL语句的查询结果自动封装为domain对象或者包装对象VO，同时也可以将domain对象中的属性数据映射到SQL语句之中 三. MyBatis的基础demo 创建一个domain对象： 123456public class Role { private Long id; private String roleName; private String note; // getter and setter 方法....} 创建dao层的映射器接口，使用动态代理技术可以生成该接口的对象用于操作数据库： 123456789101112public interface RoleMapper { // crud int insertRole(Role role); int deleteRole(Long id); int updateRole(Role role); Role getRoleById(Long id); List&lt;Role&gt; findRoles(String roleName);} 创建xml映射文件RoleMapper.xml，这文件通常是mybatis最复杂最重要的文件： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- namespace元素: 用于指定mapper接口的路径，关联mapper接口 --&gt;&lt;mapper namespace=\"com.znker.repository.RoleMapper\"&gt; &lt;!-- id元素值和Mapper接口中的方法名称必须一致，这样调用Mapper接口中的方法时mybatis 才知道发送哪一条SQL语句 parameterType元素表示SQL语句的入参类型，可以是基本类型、String、pojo...没有使用 别名的时候要使用pojo的全路径名称 #{id}是占位符，用于表示传递给SQL的参数 --&gt; &lt;insert id=\"insertRole\" parameterType=\"com.znker.domain.Role\"&gt; insert into t_role(role_name, note) values(#{roleName}, #{note}) &lt;/insert&gt; &lt;delete id=\"deleteRole\" parameterType=\"long\"&gt; delete from t_role where id = #{id} &lt;/delete&gt; &lt;!-- mybatis具有强大的自动映射功能，只要列名和属性名称一致即可 --&gt; &lt;delete id=\"updateRole\" parameterType=\"com.znker.domain.Role\"&gt; update t_role set role_name = #{roleName}, note = #{note} where id = #{id} &lt;/delete&gt; &lt;select id=\"getRoleById\" parameterType=\"long\" resultType=\"com.znker.domain.Role\"&gt; select id, role_name as roleName, note from t_role where id = #{id} &lt;/select&gt; &lt;select id=\"findRoles\" parameterType=\"string\" resultType=\"com.znker.domain.Role\"&gt; select id, role_name as roleName, note from t_role where role_name like concat('%', #{roleName}, '%') &lt;/select&gt;&lt;/mapper&gt; mybatis的核心配置文件：mybatis-config.xml，这个配置文件的内容将会影响mybaits的运行方式，例如可以在配置文件中加入mybatis的分页插件 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 配置数据源，可以配置多个环境（开发、生产...）与spring整合之后交由spring配置 --&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"1234\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!-- 加载domain的映射文件，可以依次加载，也可以使用文件扫描批量加载 --&gt; &lt;mappers&gt; &lt;mapper resource=\"mapper/RoleMapper.xml\" /&gt; &lt;/mappers&gt; &lt;/configuration&gt; SqlSessionFactory的工具类，使用单例模式创建SqlSessionFactory对象： 123456789101112131415161718192021222324252627282930313233343536373839404142public class SqlSessionFactoryUtils { private final static Class&lt;SqlSessionFactoryUtils&gt; LOCK = SqlSessionFactoryUtils.class; private static SqlSessionFactory sqlSessionFactory = null; // 构造方法 private SqlSessionFactoryUtils(){ } public static SqlSessionFactory getSqlSessionFactory(){ // 防止在多线程环境中多次实例化SqlSessionFactory对象 synchronized (LOCK){ if (sqlSessionFactory != null){ return sqlSessionFactory; } InputStream inputStream; try { // 加载mybatis核心配置文件，创建SqlSessionFactory对象 inputStream = Resources.getResourceAsStream(\"mybatis/mybatis-config.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e){ e.printStackTrace(); return null; } return sqlSessionFactory; } } public static SqlSession openSqlSession(){ if (sqlSessionFactory == null){ getSqlSessionFactory(); } return sqlSessionFactory.openSession(); }} 测试demo 12345678910111213141516171819202122232425262728293031323334353637383940414243public class RoleTest { private SqlSessionFactory sqlSessionFactory = null; @Before public void beforeTest(){ sqlSessionFactory = SqlSessionFactoryUtils.getSqlSessionFactory(); } @Test public void testGetRole(){ SqlSession sqlSession = sqlSessionFactory.openSession(); try { // 使用SqlSession对象获取Mapper接口对象，调用接口中定义的方法，发送SQL操作数据库 RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class); Role role = roleMapper.getRoleById(101L); System.out.println(role); } finally { if (sqlSession != null){ sqlSession.close(); } } } @Test public void testFindRoles(){ SqlSession sqlSession = sqlSessionFactory.openSession(); try { RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class); // 通过Mapper接口去发送SQL语句，这是面向对象的方法，便于理解 List&lt;Role&gt; list = roleMapper.findRoles(\"znker\"); System.out.println(list); } finally { if (sqlSession != null){ sqlSession.close(); } } }} 四. MyBatis的核心配置文件Mybatis的配置文件中有很多配置项可以使用，会影响mybatis的底层运行逻辑，大部分时候可以使用默认值就可以了，无需手动配置，其中使用比较多的配置项有：别名设置Alias、插件配置、mapper映射文件加载 别名Alias：当应用中的类全限定名称很长的时候，如果多次引用会很不方便，此时可以使用别名。Mybatis的别名分为系统内置别名和自定义别名。系统内置别名：java基本类型、String、Collection（list / map / hashmap）、date….这些类型的别名mybatis已经默认注册好了，可以直接使用。自定义别名需要自己注册到mybatis中才能使用，例如应用中的domain 12345678910&lt;!-- 依次手动注册别名 --&gt;&lt;typeAliases&gt; &lt;typeAlias alias=\"type\" type=\"com.znker.domain.Role\" /&gt; &lt;typeAlias alias=\"user\" type=\"com.znker.domain.User\" /&gt;&lt;/typeAliases&gt;&lt;!-- 使用包扫描批量注册别名 --&gt;&lt;typeAliases&gt; &lt;package name=\"com.znker.domain\" /&gt;&lt;/typeAliases&gt; 加载xml映射器文件 12345678910&lt;!-- 手动加载所有映射文件 --&gt;&lt;mappers&gt; &lt;mapper resource=\"com/znker/repository/RoleMapper.xml\" /&gt; &lt;mapper resource=\"com/znker/repository/UserMapper.xml\" /&gt;&lt;/mappers&gt; &lt;!-- 使用包扫描机制批量加载有所映射文件 --&gt;&lt;mappers&gt; &lt;package name=\"com.znker.repository\" /&gt;&lt;/mappers&gt;","link":"/2019/01/05/mybatis/mybatis-base-configuration/"},{"title":"Spring基础：依赖注入","text":"Spring轻量级容器技术为管理应用中的组件提供了非常棒的方法，已经成为java服务端开发事实上的标准 一. Spring概述Spring是一种轻量级的容器化技术Container，它的核心概念是控制反转IoC和依赖注入DI。在spring容器中，应用程序中的组件@Component被创建、装配彼此间依赖关系，并以一种“开箱即用”的方式对外提供组件获取服务。作为容器，最基本的功能应该有： 组件Bean的生命周期管理：组件的创建与初始化，这也是容器技术最核心的功能 依赖解析：容器中的Bean是互相依赖，容器应该能解析组件之间的依赖关系并完成依赖项的装配 组件查找：容器应该对外提供接口，使得程序能够从容器中获取容器管理的组件对象getBean(“xxx”) 应用程序的配置：应该如何将程序中的java类定义为容器中的组件，如何描述组件之间的依赖关系，这些也是容器技术中不可或缺的。一般使用某种配置方式（xml或注解），容器可以从这些配置项中获取组件的配置信息，解析配置信息，创建组件并完成依赖项的装配@Autowired 控制反转： 控制反转是spring中的核心概念，spring容器的工作原则是创建这些组件以及所依赖的组件，并将这些组件装配在一起。对依赖项的控制由组件本身转移到容器，这种模式被称为控制反转（Inversion of Controll）。 依赖注入： 依赖注入的基本原则是应用中的组件不应该自己查找它们所依赖的组件，而是由spring容器创建组件对象并完成依赖项的注入，从而导致资源查找的外部化（xml配置文件或者注解）。 二. 依赖注入1. Spring IoC容器： 使用spring容器技术的关键是： 如何将系统中的需要由容器管理的java对象注册为容器的中组件Bean，就是如何定义Bean组件，主要有三种方式：xml配置文件、注解驱动开发和使用基于java配置类@Configuration、@Bean定义组件信息 依赖解析：如何解析容器中Bean的依赖关系，如何自动装配容器中组件的依赖项@Autowired 配置元数据的传统格式是XML，可以在xml配置文件中定义Bean，描述组件之间的依赖关系，spring容器在启动的时候会加载xml配置文件，解析组件之间的依赖关系，完成组件依赖项的注入，这正是spring容器技术的提供的强大功能！如果使用基于xml的配置方法，那么在组件中依赖项的属性必须提供setter()方法！注解驱动的模式下无需提供setter方法，只需要@Autowired注解即可完成自动装配！ 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- bean标签告知spring容器将这个类的实例注册为容器中的Bean --&gt; &lt;bean id=\"accountService\" class=\"com.znker.service.impl.AccountServiceImpl\"&gt; &lt;!-- 该对象有一个AccountDao类型的属性，此处使用ref标签引用容器中的一个对象注入到bean中--&gt; &lt;!-- 因为没有使用注解驱动开发模式，所以此时需要为accountDao属性提供setter方法 --&gt; &lt;property name=\"accountDao\" ref=\"accountDao\"/&gt; &lt;/bean&gt; &lt;bean id=\"accountDao\" class=\"com.znker.dao.impl.AccountDaoInMemoryImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; Spring容器本身也是一个对象，需要在特定的时间点被创建，用于管理应用中的其它对象。在非web环境的独立应用中使用java编程的方式手动实例化spring容器，而在Web应用中可以在web.xml配置文件中声明spring容器对象，系统启动时会创建一个ApplicationContext类型的容器 1234567891011public class MainXmlBase { public static void main(String[] args) throws Exception { // 实例化一个使用xml配置文件定义的spring容器对象 ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"classpath:spring/applicationContext.xml\"); // Bean查找，从容器中获取开箱即用的bean对象，这些bean对象已经完成了依赖项的注入 AccountService accountService = applicationContext.getBean(\"accountService\", AccountService.class); }} 使用基于java注解的配置元数据，这也是流行的ssm开发模式的配置方式。Spring提供了@Component 注解，在应用中的类上加上这个注解表示需要将这个类的一个实例注册为容器中的Bean，该注解还有三个派生注解@Controller、@Service、@Repository，它们和@Component 的功能是一样的。因为无需手动在xml中定义bean，此时可以使用@Autowired 注解来描述组件之间的依赖关系，Spring容器在初始化的时候会解析这些依赖关系并完成依赖项的自动装配 1234567891011121314// 当spring容器看到这两个注解的时候，就会实例化一个它们的对象注册到容器中// Bean的名称默认为类名的首字母小写@Servicepublic class AccountServiceImpl implements AccountService { // 描述依赖关系 @Autowired private AccountDao accountDao; // other code...}@Repositorypublic class AccountDaoInMemoryImpl implements AccountDao { // other code...} 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描，将加了@Component及其派生注解的类注册为容器中的Bean，注解扫描会逐层 扫描指定包及其子包下的所有类，尝试识别带有@Component的类。同时根据@Autowired注解解析 依赖关系，完成依赖项的装配 --&gt; &lt;context:component-scan base-package=\"com.znker\"/&gt; &lt;/beans&gt; 使用基于java类的配置元数据，这应该是现在最流行的配置方式了，因为Spring Boot正是基于此技术开发的。基于java类的配置元数据舍弃了繁琐的xml配置文件，使用带有@Configuration注解的java类告知容器这是一个带有配置元数据的配置类，解析这个类可以获取配置信息及组件的依赖关系，使用@Bean注解将配置类中方法的返回对象注册为容器中的Bean。默认的情况下，系统的中Bean都是单实例的singleton，方法的多次调用并不会创建多个实例，这是由spring容器所保证的，细节待究 1234567891011121314151617181920212223// 告知Spring容器这是一个配置类Bean，解析该类可以获取配置元数据@Configurationpublic class Ch2BeanConfiguration { // @Bean注解告知容器将方法的返回值注册为容器中的Bean，这些方法在容器启动的时候被调用 // 这相当于在xml文件中定义&lt;bean&gt;组件和描述组件依赖关系 @Bean public AccountService accountService() { AccountServiceImpl bean = new AccountServiceImpl(); // 手动定义组件之间的依赖关系，依赖注入的属性需要提供setter方法 bean.setAccountDao(accountDao()); return bean; } // 默认情况下方法的名称就是返回对象的名称，默认情况的Bean都是单实例的 @Bean public AccountDao accountDao() { AccountDaoInMemoryImpl bean = new AccountDaoInMemoryImpl(); return bean; }} 12345678910public class MainJavaBase { public static void main(String[] args) throws Exception { // 实例化spring容器的方式和xml配置元数据的方式不同，传入的参数是一个配置类 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(Ch2BeanConfiguration.class); } // other code...} 在基于java类的配置下，注解@ComponentScan 可以在配置类上指定注解扫描的包，相当于在xml文件中配置&lt;context:component-scan base-package=&quot;com.znker&quot;/&gt;，这样就不需要使用带有@Bean 注解的工厂方法来手动定义应用的的Bean组件了，使用@Component 注解标识Bean组件更加方便，@Bean注解一般用于标注第三方组件的获取，例如RestTemplate. 此时就是将基于注解的方式和基于java配置类的方式组合起来使用。 2. 依赖注入： Spring容器依赖注入主要有两种方式：setter方法注入和构造函数注入。setter方法注入是在Bean实例创建完毕之后执行的，setter方法注入需要为被注入的属性提供setter方法，在传统的xml模式的配置方式下使用，但是在注解驱动已经成为主流的现在，setter注入不在推荐使用。setter注入除了可以注入对象外，还可以注入value或集合对象@Value 构造函数注入需要为Bean提供构造函数，参数为需要注入的属性，也不推荐使用。 依赖解析的过程：spring容器的启动主要分为两个阶段，首先容器先加载配置元数据；然后完成Bean的创建，注入各个组件所需要的依赖项。一个Bean在被完全创建且自己所有的依赖项被注入之前是不会作为一个依赖项被注入到其他Bean中去的，这正是为何spring容器可以做到组件的开箱即用！！！ 自动装配：有时无需显式地在Bean的定义中定义依赖项，可以让spring容器自动地向Bean中注入依赖项，该过程称为自动装配@Autowired。自动装配有三种模式：byType、byName、constructor，在byType模式下，spring通过反射技术查看Bean依赖的属性类型，然后从容器中尝试寻找和属性类型匹配的依赖项注入！ 12345678&lt;!-- 这是基于xml元数据的方式配置自动装配，在没有开启注解时这种模式下spring容器是不会去识别注解的， 依赖项的属性必须提供setter方法完成依赖注入！ byType是按类型注入的，其原理是java使用反射技术获取属性的类型，然后去容器中查找 类型匹配的Bean完成注入，此时无需使用ref标签描述依赖项--&gt;&lt;bean id=\"accountService\" class=\"com.znker.service.impl.AccountServiceImpl\" autowire=\"byType\" /&gt;&lt;bean id=\"accountDao\" class=\"com.znker.dao.impl.AccountDaoInMemoryImpl\"/&gt; 在基于java和基于注解的开发模式下，可以在组件属性上放置@Autowired 注解，这样就不需要为属性注入编写Setter方法了，此时spring利用反射技术api对字段进行直接访问，完成依赖项的注入操作（基本都用这种方法）。 以上都是装配的对象，有的时候要装配基本类型的值，比如数据连接参数通常是字符串。可以在xml配置文件中添加&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt; 或者在java配置类上使用注解@ImportResource(&quot;classpath:/com/acme/properties-config.xml&quot;) 引入属性文件，然后在java类的属性上使用@Value(&quot;${fooName}&quot;) 注解获取配置项的值，完成依赖注入。 3. Spring容器管理Bean： 被spring容器创建和管理的java对象称为Bean，容器中的Bean通过id或name进行区分，如果开发者没有显式命名Bean，容器将会为Bean分配一个内部名称。@Component 注解接收一个String值作为Bean的名称，如果没有提供，将使用类名首字母小写作为Bean的名称 1234567891011@Configuration@ComponentScan({\"com.znker\"})public class Ch2BeanConfiguration { // name元素可以给Bean赋值多个名称值 @Bean(name = {\"accountDao, accountDaoInMemory\"}) public AccountDao foo() { AccountDaoInMemoryImpl bean = new AccountDaoInMemoryImpl(); return bean; }} Bean的作用域scope：默认情况下，由spring容器创建的Bean的生命周期都是singleton单例模式的，换句话说一个Bean定义在容器中只有一个Bean实例！第二种作用域是prototype，类似于在代码中使用new操作符创建对象，每当从容器中获取Bean的时候，返回的都是一个新的Bean实例。Spring2.5中针对web环境还增加了request作用域和session作用域。 三. 小结本节主要讨论了如何在容器中定义Bean组件@Component，如何装配Bean组件之间的依赖关系@Autowired. 传统的基于xml配置元数据的方法，需要在xml文件中定义所有Bean组件，使用ref标签描述依赖关系，同时需要在java类中为依赖注入的属性提供setter方法，因为这个过程过于繁琐，已经不推荐再使用。基于注解驱动开发的模式大大简化了Bean定义和依赖描述的过程。@Component 注解及其派生注解可以将java类自动注册为容器中的Bean，@Autowired 注解用于描述依赖关系，无需再提供setter方法，但要记得开启注解扫描&lt;context:component-scan base-package=&quot;com.znker&quot;/&gt;。 而对于一些第三方组件，比如DataSource、RedisTemplate等都可以在xml中手动配置Bean。但是在Spring Boot已然成为大趋势的现在，基于java类的元数据配置方式越来越流行，@Configuration 注解标识的定义类相当于xml配置文件，@Bean 表示的方法返回的对象会被自动注册为容器中的Bean，@ComponentScan 相当于开启了注解扫描，抛弃繁琐的xml配置文件真好！","link":"/2018/12/07/spring/spring-base-dependency-injection/"},{"title":"MySQL备忘录","text":"MySQL基础操作笔记 一. MySQL中的基本概念 表（table）是一种结构化的文件，用于存储特定类型的数据。在同一个数据库中表名具有唯一性。 列（column）是表中的字段，表中的每个字段都有对应的数据类型type，它定义了该列中可以存储的数据类型 行（row）是指表中的一条条记录（record） 主键（primary-key）是表中的一列，其值能够唯一区分表中的每一行。表中任意两行的主键值不能相同（唯一性），每一行都必须要有一个主键值（主键列不能为NULL值），不要在主键中使用可能会改变的值 SQL（Structured-Query-Language）结构化查询语言，专门用于和数据库通信，从数据库中读写数据 二. 简单查询语句 检索指定列：在需要检索表中指定列的数据的时候，只需要指定列名和表名即可 12## 指定表名，多个列之间使用逗号隔开SELECT prod_id, prod_name, prod_price FROM products; 检索所有列：使用通配符（*）可以检索表中所有列的数据，一般与where子句搭配使用，检索指定记录（record）的全部字段值，否则就是检索全表数据了 12## 检索全表数据SELECT * FROM products; 限制结果：当符合条件的检索结果有很多条记录的时候（例如全表数据），为了前端可以分页展示查询结果，可以使用LIMIT子句。LIMIT子句可以指定开始行和本次检索需要展示的记录数，这是mysql中分页查询的基本原理。LIMIT子句在sql查询语句的末尾，逻辑是先查询出所有符合条件的记录，然后再分页返回数据 12## 检索结果的第一行是0而不是1SELECT * FROM products LIMIT 5,5; 排序检索：ORDER BY 子句可以对检索出的结果按指定列column进行排序，同时还可以指定排序方向，默认是升序的，使用DESC关键字可以指定降序排列 1234## 按多个列进行排序，先按第一个字段值进行排序，## 第一个字段值相同的时候再按第二个字段值排序SELECT prod_id, prod_price, prod_name FROM productsORDER BY prod_price DESC, prod_name; 三. 过滤数据在使用mysql进行查询的时候通常只需要检索出指定行的记录而不是全表记录，此时可以使用where子句设置检索条件（criteria）来过滤数据。where子句除了能做等值查询（eg.检索指定id的记录）也能做范围查询（&gt;= , &lt; , between，!= …） 12345678## 等值检索SELECT * FROM products WHERE prod_price = 2.5## 小于等于SELECT * FROM products WHERE prod_price &lt;= 10;## 范围检索，指定开始值和结束值SELECT * FROM products WHERE prod_price BETWEEN 5 AND 10; 可以使用逻辑操作符（AND / OR）来组合where子句建立高级检索条件（多条件组合查询），SQL在处理OR操作符之前会优先处理AND操作符，为了避免出现歧义，可以使用括号： 12345## AND关键字指示mysql只返回满足所有条件的记录SELECT * FROM products WHERE vend_id = 1003 AND prod_price &lt;= 10;## OR关键字指示mysql检索出满足任一条件的记录SELECT * FROM products WHERE vend_id = 1002 OR vend_id = 1003; 在where子句中可以使用IN操作符来指定检索条件值得范围，此外IN操作符可以包含select语句，这样就可以实现子查询功能。相反，NOT操作符否定它之后跟的任何条件 123## IN操作符，在mybatis中前端可以传一个数组过来，后台用List封装后传给mybatisSELECT prod_name, prod_price FROM productsWHERE vend_id IN (1002, 1003) ORDER BY prod_name; 使用通配符（%）和LIKE操作符可以对指定字段进行模糊查询，通配符（%）表示任意字符出现任意次数 123## 使用通配符进行模糊查询SELECT prod_id, prod_name FROM productsWHERE prod_name LIKE \"%anvil%\"; 四. 数据分组分组允许将数据分为多个逻辑组，以便能对每个组进行聚集计算，创建逻辑分组使用GROUP BY子句 1234## 将产品按供应商id进行逻辑分组，然后分别统计每个分组的数据量SELECT vend_id, COUNT(*) AS num_prodsFROM productsGROUP BY vend_id; MySQL还允许使用HAVING子句过滤分组，与where子句不同的是，where子句是对行过滤而HAVING子句是对分组过滤 12345## 统计订单数大于等于2的用户idSELECT cust_id, COUNT(*) AS ordersFROM ordersGROUP BY cust_idHAVING COUNT(*) &gt;= 2; 五. 联结查询（很难很重要）SQL最强大的功能之一就是在使用select进行数据检索时执行表联结（join），但是在互联网应用中很多时候不建议使用联结查询，因为数据量很大（千万级）的时候联结查询会使数据库性能直线下降，在数据库设计的时候尽量是单表的curd，在coding的时候可以使用多次查询数据库代替联结查询。而且在分库分表的架构设计中有的时候表不在同一个数据库中根本无法进行联结查询。 关系型数据库中的表是关系表，它将信息分散在多个表中存储以减少信息冗余（例如订单表中不需要存储客户信息，只需要存储一个客户主键值作为外键用于关联用户表）。关系表使用外键来定义两个表之间的关系，外键是表中的一列它的值是另一张表中的主键。 创建联结：指定需要联结的表和关联条件 12345## 关联了两张表，外键为关联条件SELECT vend_name, prod_name, prod_priceFROM vendors, products # 需要联结的表WHERE vendors.vend_id = products.vend_id # 联结的条件ORDER BY vend_name, prod_name; 在联结两张表的时候，实际上是将第一张表中的每一行与第二张表中每一行配对，而where子句作为过滤条件用于过滤出只包含那些匹配联结条件的行，如果联结的时候没有给定where子句将返回笛卡尔积 当两张表联结的时候可以使用内联结语法 12345## 内联结SELECT vend_name, prod_name, prod_priceFROM vendors INNER JOIN productsON vendors.vend_id = products.vend_idORDER BY vend_name; 多表关联查询： 123456## 业务需求：查询购买商品'TNT2'的用户信息，字段prod_id在orderitems表中SELECT cust_name, cust_contactFROM customers, orders, orderitemsWHERE customers.cust_id = orders.cust_id AND orders.order_num = orderitems.order_num AND prod_id = 'TNT2'; 外联结：有的时候联结需要关联那些在相关表中没有关联行的行，例如统计用户下单数的时候需要关联那些尚未下单的客户，此时使用内联结的时候结果将不包括未下单的客户。左外联结查询是将左表中的每一行与右表中每一行匹配，再通过联结条件过滤出指定的行，如果右表中没有与左表中指定的行关联，则左表指定行关联null值 123456789101112## 左外联结查询，如果右表中没有与左表中关联的行，## 则左表中关联值为NULLSELECT customers.cust_id, order_num FROM customers LEFT OUTER JOIN ordersON customers.cust_id = orders.cust_id;## 带有聚集函数的联结，统计用户下单数，包括尚未下单的用户SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_orderFROM customers LEFT OUTER JOIN ordersON customers.cust_id = orders.cust_idGROUP BY customers.cust_id; 六. 增删改操作INSERT 语句用于向表中插入记录，如果在insert语句省略了某些列，恰好该列不允许NULL值或者没有给定默认值，则mysql将返回一条错误信息，但是oop编程中一般都是插入一整条记录 1234## 字段名称和字段值位置必须一一对应INSERT INTO customers(cust_name,cust_contact,cust_email,cust_address,cust_city,cust_state,cust_zip,cust_country) VALUES('Pep E. LaPew',NULL,NULL,'100 Main Street','Los Angeles','CA','90046','USA'); UPDATE 语句用于更新表中记录，使用update语句时一定不能丢失where子句！ 1234## 在更新前先查询记录，然后根据需要更新数据## mybatis在执行update之前一般先查询原始record然后根据需求替换属性，最后将所有数据update到数据库UPDATE customers SET cust_name = 'The Fudds', cust_email = 'elemer@fudd.com'WHERE cust_id = 10005; DELETE 语句用于删除表中记录，使用delete语句时切记不能丢失where子句，否则只能跑路了！ 1DELETE FROM customers WHERE cust_id = 10006; 七. 创建表创建表一般有两种方法：一种是使用Navicate之类的可视化交互工具操作，另一种就是mysql命令行了 123456789101112CREATE TABLE `customers` ( `cust_id` int(11) NOT NULL AUTO_INCREMENT, `cust_name` char(50) NOT NULL, `cust_address` char(50) DEFAULT NULL, `cust_city` char(50) DEFAULT NULL, `cust_state` char(5) DEFAULT NULL, `cust_zip` char(10) DEFAULT NULL, `cust_country` char(50) DEFAULT NULL, `cust_contact` char(50) DEFAULT NULL, `cust_email` char(255) DEFAULT NULL, PRIMARY KEY (`cust_id`)) ENGINE=InnoDB 在创建表的sql语句中主要做了一下设定： 指定列名称column 指定列中存储的数据的类型type 指定列中的值是否可以是null，或者指定列的默认值，允许null值的列在插入数据的时候可以不给定值 指定表中的主键列primary key，同时可以指定主键为自增auto_increment，那么主键值将由数据库生成，应用层插入数据的时候无需手动指定主键值 引擎类型：mysql中有一个具体管理和处理数据的内部引擎，在mysql中打包了多个引擎，它们功能不同，在使用的时候要注意区别： InnoDB：具有可靠的事务处理的引擎，但不支持全文检索，可以作为读写分离中的只写数据库 MyISAM：一个高性能的引擎，支持全文检索但不支持事务处理，可以作为只读数据库 MEMORY：与MyISAM类似，但它的数据是在内存中而不是磁盘中，速度很快，适合用作临时表 八. MySQL中的数据类型数据类型主要有两个作用： 限制该列column中可以存储的数据的类型，如果插入不兼容的数据类型mysql将会报错，例如试图在char类型的数据列中插入int类型的数据将会报错 数据类型允许mysql在内部更加有效地存储数据 常见的数据类型有：串数据类型、数值数据类型、日期和时间类型 串数据类型：串类型的数据在sql语句中必须使用单引号括起来，这是和数值类型的区别 char：1~255个字符的定长串，它的长度在创建时必须指定，例如char(20) varchar：长度可变，最多不超过255个字节，在创建的时候指定为varchar(n)，则可存储0~n个字符的可变长度串 text：最大长度为64k的可变长度文本 一些看似数值类型的数据其实应该以串存储更加方便，比如电话号码，而一些以0开头的数据如果以数值存储将丢失开头的0 数值类型：mysql中数值类型的数据默认是有符号的，可以存储正负数 int：存储整数值，范围大概是正负21亿 bigint：存储整数值，范围是天文数字大概几百亿亿的样子….对应java中的long类型 double：双精度浮点值，可用于存储小数 decimal：精度可变的浮点值 日期和时间数据类型： date：表示1000-01-01 ~ 9999-12-31的日期，格式为YYYY-MM-DD time：格式为HH:MM:SS datetime：是date和time的组合 二进制数据类型：可用于存储图像、多媒体文件、文档，常见的数据类型是blog，最大长度是64k，这种设计非常不推荐，应该果断抛弃，图像文档等数据应该存储在文件服务器中，而不是数据库，数据库中应该存储的是这些文件的链接用于访问","link":"/2018/11/15/mysql/mysql-memo/"},{"title":"Spring基础：webmvc笔记","text":"Spring MVC 是Spring提供了Web MVC应用框架 一. Spring MVC 概述MVC模式是一种设计理念，其核心思想是将应用程序中的模块进行解耦。在早期的javaweb开发过程中使用的是servlet+javabean+jsp的模式，servlet负责接收客户端的http请求，然后调用应用中的Javabean组件完成业务逻辑（读写数据库），最后servlet将处理后的Model模型数据对象转发给jsp模板页面用于数据渲染。在这种模式中，servlet扮演的是控制器Controller的角色，javabean负责完成业务逻辑并返回数据模型Model，而jsp则是一种模板视图技术View。视图技术是多样化的，随着移动互联网的崛起，前后端分离已成大趋势，而JSON也逐渐成为最流行的前后端数据交互方式。 二. Spring MVC 组件的工作流程SpringMVC是一种基于servlet的技术，以DispatcherServlet 组件为核心前端控制器，首先spring mvc在初始化的时候会解析http请求的”路由”信息@RequestMapping，建立URL和处理器之间的映射关系HandlerMapping，DispatcherServlet会拦截http请求，然后查询HandlerMapping找到对应的的Handler去处理请求。处理器完成了业务逻辑之后返回模型视图对象ModelAndView，如果视图是逻辑视图（jsp / freemarker），dispatcherservlet会将模型视图对象转发给对应的视图解析器ViewResolver处理，视图解析器会将模型中的数据Model渲染到模板视图中；如果不是逻辑视图（JSON），则控制器Controller会将返回结果序列化之后直接发送给客户端，此时可以借助@ResponseBody 注解。 三. Hello Spring MVC首先使用maven构建一个javaweb工程，引入spring mvc的依赖，然后在web.xml配置spring容器 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;!-- 指定Spring容器配置文件的位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- ContextLoaderListener用于初始化Spring容器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- Spring MVC的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-web.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!-- 告诉spring mvc拦截所有以.do结尾的http请求 --&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 在spring-web.xml配置文件中配置MVC框架的属性 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 注解驱动配置MVC --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 组件扫描，加载指定包下的带有@Controller注解的类，并注册实例为Bean --&gt; &lt;context:component-scan base-package=\"com.znker.controller\"/&gt; &lt;!-- 配置jsp视图解析器 物理视图名 = 前缀 + 逻辑视图名 + 后缀 --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- /WEB-INF/jsp/index/index.jsp --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;ref bean=\"jsonConverter\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置JSON视图解析器，用于将应用中的模型数据直接序列化为JSON字符串 --&gt; &lt;bean id=\"jsonConverter\" class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;application/json; charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 编写@Controller 组件用于处理客户端请求 123456789101112131415@Controller@RequestMapping(\"/my\")public class MyController { // @RequestMapping指定了对应的请求URI， // Spring MVC在初始化的时候会解析并保存这些信息，这就是HanderMapping @RequestMapping(\"/index\") public ModelAndView index(){ // 创建一个模型视图对象 ModelAndView mv = new ModelAndView(); // 设置逻辑视图名称 mv.setViewName(\"index\"); return mv; }} 使用注解的方式配置Spring MVC 123456789101112131415@Configuration@ComponentScan(\"com.znker.controller\")// 相当于在xml中配置&lt;mvc:annotation-driven/&gt;@EnableWebMvcpublic class WebConfig { @Bean(value = \"viewResolver\") public ViewResolver initViewResolver() { InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); viewResolver.setPrefix(\"/WEB-INF/jsp/\"); viewResolver.setSuffix(\".jsp\"); return viewResolver; }} 四. Spring MVC的开发流程 @RequestMapping 注解可以配置在类或方法上，用于映射URL和控制器中处理器的方法，作为一个处理器响应请求。@RequestMapping 注解中除了可以配置请求路径value之外，还可以指定HTTP请求的方法的类型，即GET、POST、DELETE、PUT等方法，Spring 4.3之后增加了@GetMapping，@DeleteMapping 等注解用于简化开发 12345678910// 只能响应GET类型的请求，如果不配置method参数，那么所有类型的请求都可以响应@RequestMapping(value = \"/index\", method = RequestMethod.GET)public ModelAndView index(){ // 创建一个模型视图对象 ModelAndView mv = new ModelAndView(); // 设置逻辑视图名称 mv.setViewName(\"index\"); return mv;} @Controller 控制器的开发主要分为三步： 获取http请求中的参数，@RequestParam，@RequstBody，@PathVariable 这些注解都可以获取http请求中的参数，后面详解 调用容器中的Bean处理业务逻辑，返回处理结果数据Model 绑定模型参数ModelAndView，视图主要有两种：逻辑视图和非逻辑上视图，像jsp这种就是逻辑视图，需要视图解析器去解析出真实的物理路径才行，而JSON这种格式的响应数据只需要将模型参数数据直接序列化后发送到客户端即可 12345678910// http://localhost:8080/my/getRole.do?id=101@RequestMapping(value = \"/getRole\", method = RequestMethod.GET)public ModelAndView getRole(@RequestParam(\"id\") Long id) { Role role = roleService.getRole(id); ModelAndView mv = new ModelAndView(); // 指定视图类型，此处是非逻辑视图，spring mvc从容器中寻找该类型的视图解析器 mv.setView(new MappingJackson2JsonView()); return mv;} 五. 控制器接收各类请求参数使用控制器接收请求参数是开发业务逻辑的第一步，除了以http请求参数传参之外，还有Restful风格的请求，它将请求参数嵌入到URL中；而对于那些需要传很多参数的请求，比如用户注册是的表单form，前端可能会将请求参数序列化为一个JSON字符串传给后端。 接收普通参数：如果http请求中的参数名称和处理器中的参数名称相同，那么无需任何注解就可以获取参数。如果参数名称不一致是无法获取的，该方法允许参数为空null。无需任何注解的情况下，spring mvc也可以将请求参数映射pojo的属性，只要http请求参数名称和pojo的属性名称一致即可完成映射，这对于前端一次性要穿很多参数来说非常管用，这是将参数封装到pojo中便于使用后续方法调用！ 123456789101112131415161718192021222324// 无需任何注解即可获取请求参数，不管是GET还是POST类型的请求都可以// 请求参数的名称要和处理器中的参数名称一致，不一致则取不到值，为null@RequestMapping(value = \"/commonParams\")public ModelAndView commonParams(String roleName, String note) { System.out.print(\"roleName =&gt; \" + roleName); System.out.print(\"note =&gt; \" + note); ModelAndView mv = new ModelAndView(); mv.setViewName(\"index\"); return mv;}// 将请求参数自动映射到pojo中，只要参数名称和pojo中属性名称一致即可@RequestMapping(value = \"/commonParamPojo\")public ModelAndView commonParamsPojo(RoleParams roleParams) { System.out.print(\"roleName =&gt; \" + roleParams.getRoleName()); System.out.print(\"note =&gt; \" + roleParams.getNote()); ModelAndView mv = new ModelAndView(); mv.setViewName(\"index\"); return mv;} 使用@RequestParam 注解获取请求参数：如果前端请求参数名称和处理器中形参名称不一致时，spring mvc是无法完成自动映射的，而@RequestParam 注解可以解决这一问题，使用该注解之后默认情况下参数不能为空。这个注解还可以为处理器参数设置默认值，也就是当前端没有传这个参数时使用默认值封装。 123456789101112// @RequestParam注解可以从http请求中获取请求参数，// 可以解决参数名称和处理器形参名称不一致的问题@RequestMapping(value = \"/requestParam\")public ModelAndView requestParam(@RequestParam(\"role_name\") String roleName, String note) { System.out.print(\"roleName =&gt; \" + roleName); System.out.print(\"note =&gt; \" + note); ModelAndView mv = new ModelAndView(); mv.setViewName(\"index\"); return mv;} 使用URL传递参数：一些网站使用URL的形式传递请求参数，这符合Restful风格的架构，比如B站电影模块就是这种风格的https://www.bilibili.com/bangumi/play/ss25122。使用URL传递参数需要两个注解配合使用，@RequestMapping 注解用于映射包含参数的请求路径URL，@PathVariable 注解用从URL中获取请求参数 1234567891011121314// {id}代表处理器就收一个由URL组成的参数，且参数名称为id// @PathVariable注解用于从URL中获取请求参数@RequestMapping(value = \"/getRole/{id}\")public ModelAndView pathVariable(@PathVariable(\"id\") Long id){ Role role = roleService.getRole(id); ModelAndView mv = new ModelAndView(); // 绑定模型数据 mv.addObject(role); // 设置JSON视图 mv.setView(new MappingJackson2JsonView()); return mv;} 传递JSON参数：有的时候前端要一次传递很多参数，一般会选择将参数序列化为JSON字符串传递给后端，此时可以在处理器中使用@RequestBody 注解解析JSON字符串，并将请求参数封装到一个pojo中。与传递普通参数一样，前端传递的参数名称要和pojo属性名称一致才行完成自动映射！ 123456789101112// @RequestBody注解用于解析前端传递的JSON字符串，并将参数封装到pojo中@RequestMapping(value = \"/findRoles\")public ModelAndView findRoles(@RequestBody RoleParams roleParams) { List&lt;Role&gt; roleList = roleService.findRoles(roleParams); ModelAndView mv = new ModelAndView(); // 绑定模型 mv.addObject(roleList); // 设置视图为JSON字符串 mv.setView(new MappingJackson2JsonView()); return mv;} 传递数组参数：在批量删除的时候，前端一般会穿过来一个id数组作为请求参数，此时处理器中可以使用@RequstBody 注解解析请求参数，此时spring mvc会将字符串类型的数组参数转换为指定类型的List集合对象 12345// @RequestBody用于解析前端传递过来的字符串数组参数@RequestMapping(value = \"/deleteRoles\")public ModelAndView deleteRoles(@RequestBody List&lt;Long&gt; idList) {} 六. 模型数据ModelMap当控制器处理完业务逻辑之后，通常会返回一个对象代表处理结果，此时可以将该结果数据封装到ModelMap对象中用于转发给视图解析器ViewResolver用于jsp模板渲染。ModelAndView对象中有一个ModelMap类型的属性model，而ModelMap继承了LinkedHashMap类，可以存储键值对。 在控制器的方法中，可以添加ModelAndView、ModelMap、Model作为形参，spring mvc在运行时会初始化它们，可以在这些对象中存储处理器返回的结果数据。不管使用上面哪种类型的形参，spring mvc初始化的都是BindingAwareModelMap实例，这是一个数据绑定类。在完成控制器中的逻辑之后，spring mvc会自动地将模型数据ModelMap绑定到ModelAndView中的model属性中 12345678910111213141516171819202122232425262728293031323334353637383940414243// spring mvc在运行时会自动创建一个BindingAwareModelMap实例@RequestMapping(value = \"/getRoleByModelMap\", method = RequestMethod.GET)public ModelAndView getRoleByModelMap(@RequestParam(\"id\") Long id, ModelMap modelMap) { Role role = roleService.getRole(id); // 创建一个模型视图对象，此ModelMap属性为null // 在完成控制器中的业务逻辑之后，spring mvc会自动将modelMap绑定到ModelAndView的model属性中 ModelAndView mv = new ModelAndView(); // 逻辑视图名称 mv.setViewName(\"roleDetails\"); // 添加模型数据，在jsp可以获取这些数据 modelMap.addAttribute(\"role\", role); return mv;}// spring mvc在运行时会自动创建一个BindingAwareModelMap实例@RequestMapping(value = \"/getRoleByModel\", method = RequestMethod.GET)public ModelAndView getRoleByModel(@RequestParam(\"id\") Long id, Model model) { Role role = roleService.getRole(id); // 创建一个模型视图对象，此ModelMap属性为null ModelAndView mv = new ModelAndView(); // 逻辑视图名称 mv.setViewName(\"roleDetails\"); // 添加模型数据，在jsp可以获取这些数据 model.addAttribute(\"role\", role); return mv;}// spring mvc在运行时会自动创建一个BindingAwareModelMap实例@RequestMapping(value = \"/getRoleByMv\", method = RequestMethod.GET)public ModelAndView getRoleByMv(@RequestParam(\"id\") Long id, ModelAndView mv) { Role role = roleService.getRole(id); // 逻辑视图名称 mv.setViewName(\"roleDetails\"); // 添加模型数据，在jsp可以获取这些数据 mv.addObject(\"role\", role); return mv;} 控制器方法除了返回一个ModelAndView类型的对象之外，还可以返回一个字符串用于表示逻辑视图名称： 12345678910111213141516@RequestMapping(\"admin_user_list\")public String list(Model model, Page page) { PageHelper.offsetPage(page.getStart(), page.getCount()); List&lt;User&gt; userList = userService.list(); int total = (int) new PageInfo&lt;&gt;(userList).getTotal(); page.setTotal(total); // 添加模型数据 model.addAttribute(\"us\", userList); model.addAttribute(\"page\", page); // 返回的字符串表示逻辑视图名称，相当于以前的mv.setViewName(\"xxx\") return \"admin/listUser\";}","link":"/2018/12/21/spring/spring-base-webmvc/"},{"title":"Spring Boot文档笔记","text":"Spring Boot是目前非常流行的微服务框架，它倡导”约定优于配置”的理念，其设计目的就是为了简化Spring应用初始化搭建及开发过程，一个产品级的应用往往只需要极少Spring Boot配置就能运行起来 一. Spring Boot 初相识Spring Boot使你能够创建独立的、可运行的产品级应用。Spring Boot对Spring生态中的第三方库进行了打包，使得开发者使用很少的配置就能完成应用的搭建过程。Spring Boot应用可以打包成一个jar包，然后在命令行中使用java -jar启动应用。Spring Boot的主要设计目的是： 为所有的Spring应用提供一个快速的项目初始化过程 提供了非常多的默认配置，但这些默认配置也是可以修改的 提供了诸如内嵌web应用服务器、健康检查、外部化配置等特性 不推荐使用xml的方式进行应用元数据配置 开发环境需求，Spring Boot 2.0.8： java8 Spring 5.0 + maven 3.2 + tomcat 8.5 / servlet 3.1 Spring Boot 应用的初始化： 推荐使用maven初始化Spring Boot应用，在pom.xml中继承一个spring-boot-starter-parent的父工程，该项目对Spring应用中最常见的依赖项都提供了启动器starter，便于依赖管理；同时该项目还为应用提供了非常多的默认配置，极大的简化了应用的初始化过程 12345678910111213141516171819202122232425262728293031323334&lt;!-- 此处配置了maven项目的编码格式UTF-8，java编译级别为java8 --&gt;&lt;properties&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;resource.delimiter&gt;@&lt;/resource.delimiter&gt; &lt;maven.compiler.source&gt;${java.version}&lt;/maven.compiler.source&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.target&gt;${java.version}&lt;/maven.compiler.target&gt;&lt;/properties&gt;&lt;build&gt; &lt;!-- 项目打包的时候将配置文件一并打包，这是在spring应用中必备的配置 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/application*.yml&lt;/include&gt; &lt;include&gt;**/application*.yaml&lt;/include&gt; &lt;include&gt;**/application*.properties&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;${basedir}/src/main/resources&lt;/directory&gt; &lt;excludes&gt; &lt;exclude&gt;**/application*.yml&lt;/exclude&gt; &lt;exclude&gt;**/application*.yaml&lt;/exclude&gt; &lt;exclude&gt;**/application*.properties&lt;/exclude&gt; &lt;/excludes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!-- 其它的插件管理 --&gt;&lt;/build&gt; spring-boot-starter-parent 项目继承自spring-boot-dependencies 父工程，该项目中配置了很多第三方库的依赖版本，后续引入jar包的就无需使用&lt;version&gt; 标签手动指定版本了。典型的pom.xml配置如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 项目坐标 --&gt; &lt;groupId&gt;com.znker.boot&lt;/groupId&gt; &lt;artifactId&gt;boot_demo&lt;/artifactId&gt; &lt;version&gt;1.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 从父工程中继承spring boot默认的基础配置 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.8.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- 通过启动器starter自动导入web项目依赖项 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;!-- maven插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 应用编码： 在默认情况下，maven从src/main/java 路径下编译项目源码，在该路径下创建文件夹com.znker.demo 用于存放项目源码src/main/java/Example.java： 12345678910111213141516// @RestController是复合注解，该注解除了将java类注解为一个控制器@Controller，// 还告知spring将控制器中所有方法的返回对象全部序列化为json字符串返回@RestController// 开启自动配置@EnableAutoConfigurationpublic class Example { // 映射http请求的URL @RequestMapping(\"/\") String home() { return \"Hello Spring Boot!\"; } public static void main(String[] args) { SpringApplication.run(Example.class, args); }} @RestController 和@RequestMapping 注解都是Spring MVC中的注解，它们同样也适用于Spring Boot. @RestController 是一个复合注解，它告诉Spring将这个java注册为一个控制器，同时将该控制器中的所有方法的返回值序列化为一个json字符串返回给客户端，这样就无需使用以前的@ResponseBody 注解了。RequestMapping 注解提供了请求的”路由”信息，它告诉Spring按照http请求的路径信息将http请求映射到控制器中的方法上。 @EnableAutoConfiguration 是一个神奇的注解，它提供了应用自动配置的功能。这个注解告诉Spring Boot根据应用的依赖项去猜测开发者想要如何配置应用，由于项目中添加了spring-boot-starter-web 依赖，Spring Boot会自动加载很多已经配置好的默认配置信息，使用这些信息可以配置Spring MVC，开发者无需再手动创建繁琐的xml配置信息，解放了生产力！ “main”方法是Spring Boot项目的应用入口，调用该方法启动项目的时候也启动了一个配置好的内嵌的tomcat服务器，可以对外提供服务。 启动应用： 到这里项目就可以启动运行了，除了可以在IDE中启动项目之外，还可以使用maven命令行启动项目，在项目根目录下使用mvn spring-boot:run 命令就可以启动项目，当看到控制台输出类似下面的信息时，就代表项目已经启动了： 12345678910111213$ mvn spring-boot:run . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.8.RELEASE)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.222 seconds (JVM running for 6.514) 此时在浏览器中输入localhost:8080 就可以访问项目了，会得到Hello Spring Boot!，这就是一个可运行的完整的web项目，抛弃了以前Spring中的一大堆繁琐的xml配置，真好！ 可以在pom.xml文件中引入maven插件，这样就可以将项目打包mvn package为一个可执行的jar文件用于应用部署： 123456789&lt;build&gt; &lt;plugins&gt; &lt;!-- maven插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 使用java -jar boot_demo-1.0.1-SNAPSHOT.jar 命令就可以启动应用了。 二. 详解Spring Boot的使用本节主要介绍Spring Boot的使用细节和最佳实践 依赖管理： 使用maven进行依赖管理Spring Boot项目初始化的最佳实践是继承spring-boot-starter-parent 父工程，该项目为Spring Boot提供了很多的特性： 使用java 1.8作为默认的源码编译级别 使用UTF-8作为源码的编码方式 从spring-boot-dependencies 项目中继承依赖项版本设置，在后续引入依赖项的时候无需再指定版本 自动识别项目配置文件，application.yml，application.properties这样的配置文件会被Spring Boot自动识别并打包到jar中去 启动器Starters： Starters是一系列便于使用的依赖项描述文件，使用starters可以”一站式”地引入Spring以及相关技术的依赖项，而无需再到处copy它们的maven坐标。比如开发者想要在应用中引入jpa进行持久化操作，只需要在pom.xml文件中添加spring-boot-starter-data-jpa 依赖描述文件即可，maven会分析依赖关系，然后自动地导入所需jar包，所有的Spring Boot官方的starter都以spring-boot-starter-* 形式命名，具体信息参考文档。 应用代码的布局： Spring Boot无需特定的代码布局方式，但是有最佳实践。如果在类路径下没有什么package时，Spring Boot会将源文件都打包到一个default package 中去，但是不要这样做！这会导致@ComponentScan 和@SpringBootApplication 注解失效。最佳的实践是将项目中的源代码放到类似这样的目录结构下com.example.project. 对于Spring Boot项目的启动类Main Application推荐放到com.example.project 目录的根目录下，这样便于@ComponentScan 注解从当前路径下扫描并注册Bean，最佳实践的例子如下，注意启动类的位置： 12345678910111213141516com +- example +- myapplication +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderR、epository.java 配置元数据类@Configuration类： Spring Boot推荐基于java类的配置方式，尽管也可是使用基于xml的配置方式@ImportResource ，但是不推荐这样做。项目中可以有多个带有@Configuration 注解的java配置类，可以使用@Import 注解将其他配置类导入到主配置类中，或者也可以在启动类上使用@ComponentScan 注解，它会自动扫描并加载java配置类信息，所有带有@Component 注解的类会被注册为容器中的Bean，同时java配置类中带有@Bean注解的方法的返回值也会被自动注册为容器中的Bean. 如果无可避免地要使用基于xml的配置方式，推荐创建一个java配置类，然后在配置类上使用注解@ImportResource 去加载指定的xml配置文件，同时xml文件中的配置的组件也会被注册为容器中的Bean 自动配置Auto-configuration： Spring Boot会根据项目依赖的jar包尝试去自动配置项目，推荐在@EnableAutoConfiguration 或SpringBootApplication 中选一个添加到主配置类@Configuration 上，这样就开启了自动配置。自动配置是非侵入式的，在任何时候你都可以定义自己的配置信息来替换自动配置的信息。 依赖注入： Bean的定义和依赖注入Injection是Spring中核心，在Spring Boot中同样可以使用Spring IoC中技术。简而言之，@ComponentScan 注解的组件扫描和@Autowired 注解的依赖注入描述在Spring Boot同样有效。 如果你使用最佳实践中的代码布局方式，将启动类放在root package 下，那么@ComponentScan 注解无需任何参数就能自动扫描并加载源码中带有@Component 注解及其派生注解（@Controller，@Service，Repository）的类，并将其注册为容器中的Bean，同时也会将带有@Configuration 注解的java配置类中定义的Bean注册到Spring容器中 123456789101112// 注册为容器中的Bean@Servicepublic class DatabaseAccountService implements AccountService { private final RiskAssessor riskAssessor; // 构造函数注入 @Autowired public DatabaseAccountService(RiskAssessor riskAssessor) { this.riskAssessor = riskAssessor; }} 使用@SpringBootApplication注解： 对于使用Spring Boot的开发者而言，自动配置、组件扫描以及加载额外的配置信息都是非常通用的需求，为了默认开启这三种特性，可以在项目启动类上使用@SpringBootApplication 注解，这是一个复合注解，它由三个注解组成： @EnableAutoConfiguration：该注解用于开启Spring Boot的自动配置功能 @ComponentScan：该注解用于开启组件扫描，加载@Component 和@Configuration 类，默认的起始扫描路径启动类所在的目录，所以建议启动类放在root package 下 @Configuration：将启动类注册为项目中的主配置类，可以在启动类中使用工厂方法配合@Bean注解手动注册组件，也可以使用@Import 注解手动导入其它java配置类，或者使用@ImportResource 注解加载由xml文件定义的Bean组件 这些特性并不是强制的，比如你不想使用组件扫描，那么可以使用java配置类定义项目中所有的组件，并且使用手动描述它们之间的依赖关系，然后在启动类上使用@Import 注解导入所有自定义的java配置类信息 12345678910111213141516171819202122// java配置类@Configurationpublic class MyConfig { // 将返回的对象注册为容器中的Bean @Bean public ExampleController exampleController() { ExampleController bean = new ExampleController(); return bean; }}@Configuration@EnableAutoConfiguration// 不开启组件扫描，手动加载所有java配置类@Import({MyConfig.class})public class ExampleMainApplication { public static void main(String[] args) { SpringApplication.run(ExampleMainApplication.class, args); }} 三. 开发Web应用Spring Boot非常适合做web服务端的开发，可以使用tomcat，jetty做内嵌的服务器。大部分Spring Boot应用都需要引入spring-boot-starter-web 模块来快速搭建应用框架。Spring Boot中可以使用Spring MVC中的技术，可以使用@Controller或者@RestController 注解来标识控制器，这些控制器可以用于处理客户端的http请求，在控制器中可以使用@RequestMapping 注解来映射请求路径URL 12345678910111213141516171819@RestController@RequestMapping(value=\"/users\")public class MyRestController { @RequestMapping(value=\"/{user}\", method=RequestMethod.GET) public User getUser(@PathVariable Long user) { // ... } @RequestMapping(value=\"/{user}/customers\", method=RequestMethod.GET) List&lt;Customer&gt; getUserCustomers(@PathVariable Long user) { // ... } @RequestMapping(value=\"/{user}\", method=RequestMethod.DELETE) public User deleteUser(@PathVariable Long user) { // ... }} Web应用中的自动配置： Spring Boot为Sprring MVC提供了很多默认配置，这些配置对于大多数web应用都适用： 自动注册ContentNegotiatingViewResolver 和BeanNameViewResolver 视图解析器 支持输出静态资源，包括WebJars 自动注册Converter，GenericConverter 和Formater 组件 支持使用HttpMessageConverters 类型的组件完成消息转换 自动注册MessageCodesResolver 组件 静态欢迎页index.html 自动注册ConfigurableWebBindingInitializer 组件 如果想要保持SpringMVC的特性，并且添加其他的mvc配置（拦截器、格式化器、视图解析器….），此时可以自己实现一个WebMvcConfigurer 类，在类上添加@Configuration 注解，Spring Boot会使用这个类中的配置作为Spring MVC的配置，但是此时不能再使用@EnableWebMvc，因为这个注解是开启默认配置的。 HttpMessageConverters： Spring MVC使用HttpMessageConverter接口来实现转换http请求和响应中的信息，例如当引入Jackson工具包后，处理器中返回的对象可以自动地转换为JSON字符串@ResponseBody/@RestController , 并且默认的编码格式是UTF-8，以前在Spring MVC还需要在配置文件手动配置消息转换器","link":"/2019/02/23/spring-boot/spring-boot-notes/"}],"tags":[{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"JavaWeb","slug":"JavaWeb","link":"/tags/JavaWeb/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"MyBatis","slug":"MyBatis","link":"/tags/MyBatis/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"}],"categories":[{"name":"Language","slug":"Language","link":"/categories/Language/"},{"name":"Framework","slug":"Framework","link":"/categories/Framework/"},{"name":"Front end","slug":"Front-end","link":"/categories/Front-end/"},{"name":"DataBase","slug":"DataBase","link":"/categories/DataBase/"}]}